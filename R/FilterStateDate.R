#' @name DateFilterState
#' @title `FilterState` object for Date variable
#' @description Manages choosing a range of Dates
#' @docType class
#' @keywords internal
#'
#'
#' @examples
#' filter_state <- teal.slice:::DateFilterState$new(
#'   x = c(Sys.Date() + seq(1:10), NA),
#'   varname = "x",
#'   dataname = "data",
#'   extract_type = character(0)
#' )
#' isolate(filter_state$get_call())
#' isolate(filter_state$set_selected(c(Sys.Date() + 3L, Sys.Date() + 8L)))
#' isolate(filter_state$set_keep_na(TRUE))
#' isolate(filter_state$get_call())
#'
#' \dontrun{
#' # working filter in an app
#' library(shiny)
#' library(shinyjs)
#'
#' dates <- c(Sys.Date() - 100, Sys.Date())
#' data_date <- c(seq(from = dates[1], to = dates[2], length.out = 100), NA)
#' filter_state_date <- DateFilterState$new(
#'   x = data_date,
#'   varname = "variable",
#'   varlabel = "label"
#' )
#' filter_state_date$set_state(list(selected = data_date[c(47, 98)], keep_na = TRUE))
#'
#' ui <- fluidPage(
#'   useShinyjs(),
#'   include_css_files(pattern = "filter-panel"),
#'   include_js_files(pattern = "count-bar-labels"),
#'   column(4, div(
#'     h4("DateFilterState"),
#'     isolate(filter_state_date$ui("fs"))
#'   )),
#'   column(4, div(
#'     id = "outputs", # div id is needed for toggling the element
#'     h4("Condition (i.e. call)"), # display the subsetting call generated by this FilterState
#'     textOutput("condition_date"), br(),
#'     h4("Unformatted state"), # display raw filter state
#'     textOutput("unformatted_date"), br(),
#'     h4("Formatted state"), # display human readable filter state
#'     textOutput("formatted_date"), br()
#'   )),
#'   column(4, div(
#'     h4("Programmatic filter control"),
#'     actionButton("button1_date", "set drop NA", width = "100%"), br(),
#'     actionButton("button2_date", "set keep NA", width = "100%"), br(),
#'     actionButton("button3_date", "set a range", width = "100%"), br(),
#'     actionButton("button4_date", "set full range", width = "100%"), br(),
#'     actionButton("button0_date", "set initial state", width = "100%"), br()
#'   ))
#' )
#'
#' server <- function(input, output, session) {
#'   filter_state_date$server("fs")
#'   output$condition_date <- renderPrint(filter_state_date$get_call())
#'   output$formatted_date <- renderText(filter_state_date$format())
#'   output$unformatted_date <- renderPrint(filter_state_date$get_state())
#'   # modify filter state programmatically
#'   observeEvent(input$button1_date, filter_state_date$set_keep_na(FALSE))
#'   observeEvent(input$button2_date, filter_state_date$set_keep_na(TRUE))
#'   observeEvent(
#'     input$button3_date,
#'     filter_state_date$set_selected(data_date[c(34, 56)])
#'   )
#'   observeEvent(input$button4_date, filter_state_date$set_selected(dates))
#'   observeEvent(
#'     input$button0_date,
#'     filter_state_date$set_state(list(selected = data_date[c(47, 98)], keep_na = TRUE))
#'   )
#' }
#'
#' if (interactive()) {
#'   shinyApp(ui, server)
#' }
#' }
#'
DateFilterState <- R6::R6Class( # nolint
  "DateFilterState",
  inherit = FilterState,

  # public methods ----

  public = list(

    #' @description
    #' Initialize a `FilterState` object
    #' @param x (`Date`)\cr
    #'   values of the variable used in filter
    #' @param x_reactive (`reactive`)\cr
    #'   a `reactive` returning a filtered vector or returning `NULL`. Is used to update
    #'   counts following the change in values of the filtered dataset. If the `reactive`
    #'   is `NULL` counts based on filtered dataset are not shown.
    #' @param varname (`character`, `name`)\cr
    #'   name of the variable
    #' @param varlabel (`character(1)`)\cr
    #'   label of the variable (optional).
    #' @param dataname (`character(1)`)\cr
    #'   optional name of dataset where `x` is taken from
    #' @param extract_type (`character(0)`, `character(1)`)\cr
    #' whether condition calls should be prefixed by dataname. Possible values:
    #' \itemize{
    #' \item{`character(0)` (default)}{ `varname` in the condition call will not be prefixed}
    #' \item{`"list"`}{ `varname` in the condition call will be returned as `<dataname>$<varname>`}
    #' \item{`"matrix"`}{ `varname` in the condition call will be returned as `<dataname>[, <varname>]`}
    #' }
    initialize = function(x,
                          x_reactive = reactive(NULL),
                          dataname,
                          varname,
                          choices = NULL,
                          selected = NULL,
                          varlabel = character(0),
                          keep_na = NULL,
                          fixed = FALSE,
                          extract_type = character(0)) {
      stopifnot(is(x, "Date"))
      checkmate::assert_class(x_reactive, 'reactive')

      super$initialize(
        x = x,
        x_reactive = x_reactive,
        dataname = dataname,
        varname = varname,
        choices = choices,
        selected = selected,
        varlabel = varlabel,
        keep_na = keep_na,
        fixed = fixed,
        extract_type = extract_type)

      if (!is.null(choices)) {
        private$set_choices(choices)
        self$set_selected(choices)
        private$set_choices_limited(x, private$choices)
      } else {
        var_range <- range(x, na.rm = TRUE)
        private$set_choices(var_range)
        self$set_selected(var_range)
      }

      return(invisible(self))
    },

    #' @description
    #' Returns a formatted string representing this `DateFilterState`.
    #'
    #' @param indent (`numeric(1)`) the number of spaces before after each new line character of the formatted string.
    #' Default: 0
    #' @return `character(1)` the formatted string
    #'
    format = function(indent = 0) {
      checkmate::assert_number(indent, finite = TRUE, lower = 0)

      vals <- self$get_selected()
      sprintf(
        "%sFiltering on: %s\n%1$s  Selected range: %s - %s\n%1$s  Include missing values: %s",
        format("", width = indent),
        private$varname,
        format(vals[1], nsmall = 3),
        format(vals[2], nsmall = 3),
        format(self$get_keep_na())
      )
    },

    #' @description
    #' Answers the question of whether the current settings and values selected actually filters out any values.
    #' @return logical scalar
    is_any_filtered = function() {
      if (private$is_disabled()) {
        FALSE
      } else if (private$choices_limited) {
        TRUE
      } else if (!setequal(self$get_selected(), private$choices)) {
        TRUE
      } else if (!isTRUE(self$get_keep_na()) && private$na_count > 0) {
        TRUE
      } else {
        FALSE
      }
    },

    #' @description
    #' Returns reproducible condition call for current selection.
    #' For this class returned call looks like
    #' `<varname> >= <min value> & <varname> <= <max value>` with
    #' optional `is.na(<varname>)`.
    #' @return (`call`)
    get_call = function() {
      choices <- as.character(self$get_selected())
      filter_call <-
        call(
          "&",
          call(">=", private$get_varname_prefixed(), call("as.Date", choices[1L])),
          call("<=", private$get_varname_prefixed(), call("as.Date", choices[2L]))
        )
      private$add_keep_na_call(filter_call)
    },

    #' @description
    #' Sets the selected time frame of this `DateFilterState`.
    #'
    #' @param value (`Date(2)`) the lower and the upper bound of the selected
    #'   time frame. Must not contain NA values.
    #'
    #' @return invisibly `NULL`.
    #'
    #' @note Casts the passed object to `Date` before validating the input
    #' making it possible to pass any object coercible to `Date` to this method.
    #'
    #' @examples
    #' date <- as.Date("13/09/2021")
    #' filter <- teal.slice:::DateFilterState$new(
    #'   c(date, date + 1, date + 2, date + 3),
    #'   varname = "name", dataname = "data"
    #' )
    #' filter$set_selected(c(date + 1, date + 2))
    set_selected = function(value) {
      super$set_selected(value)
    }
  ),

  # private methods ----

  private = list(
    #' @description
    #' Check whether the initial choices filter out some values of x and set the flag in case.
    #'
    set_choices_limited = function(x, choices) {
      if (!is.null(choices)) {
        private$choices_limited <- (choices[1] > min(x)) | (choices[2] < max(x))
      }
      invisible(NULL)
    },
    validate_selection = function(value) {
      if (!is(value, "Date")) {
        stop(
          sprintf(
            "value of the selection for `%s` in `%s` should be a Date",
            self$get_varname(),
            self$get_dataname()
          )
        )
      }
      pre_msg <- sprintf(
        "dataset '%s', variable '%s': ",
        self$get_dataname(),
        self$get_varname()
      )
      check_in_range(value, private$choices, pre_msg = pre_msg)
    },
    cast_and_validate = function(values) {
      tryCatch(
        expr = {
          values <- as.Date(values)
          if (any(is.na(values))) stop()
        },
        error = function(error) stop("The array of set values must contain values coercible to Date.")
      )
      if (length(values) != 2) stop("The array of set values must have length two.")
      values
    },
    remove_out_of_bound_values = function(values) {
      if (values[1] < private$choices[1] | values[1] > private$choices[2]) {
        warning(
          sprintf(
            "Value: %s is outside of the possible range for column %s of dataset %s, setting minimum possible value.",
            values[1], private$varname, private$dataname
          )
        )
        values[1] <- private$choices[1]
      }

      if (values[2] > private$choices[2] | values[2] < private$choices[1]) {
        warning(
          sprintf(
            "Value: %s is outside of the possible range for column %s of dataset %s, setting maximum possible value.",
            values[2], private$varname, private$dataname
          )
        )
        values[2] <- private$choices[2]
      }

      if (values[1] > values[2]) {
        warning(
          sprintf(
            "Start date %s is set after the end date %s, the values will be replaced with a default date range.",
            values[1], values[2]
          )
        )
        values <- c(private$choices[1], private$choices[2])
      }
      values
    },

    # shiny modules ----

    # @description
    # UI Module for `DateFilterState`.
    # This UI element contains two date selections for `min` and `max`
    # of the range and a checkbox whether to keep the `NA` values.
    # @param id (`character(1)`)\cr
    #  id of shiny element
    ui_inputs = function(id) {
      ns <- NS(id)
      div(
        div(
          class = "flex",
          actionButton(
            class = "date_reset_button",
            inputId = ns("start_date_reset"),
            label = NULL,
            icon = icon("fas fa-undo")
          ),
          div(
            class = "w-80 filter_datelike_input",
            dateRangeInput(
              inputId = ns("selection"),
              label = NULL,
              start = self$get_selected()[1],
              end = self$get_selected()[2],
              min = private$choices[1],
              max = private$choices[2],
              width = "100%"
            )
          ),
          actionButton(
            class = "date_reset_button",
            inputId = ns("end_date_reset"),
            label = NULL,
            icon = icon("fas fa-undo")
          )
        ),
        private$keep_na_ui(ns("keep_na"))
      )
    },

    # @description
    # Server module
    # @param id (`character(1)`)\cr
    #   an ID string that corresponds with the ID used to call the module's UI function.
    # @return `moduleServer` function which returns `NULL`
    server_inputs = function(id) {
      moduleServer(
        id = id,
        function(input, output, session) {
          logger::log_trace("DateFilterState$server initializing, dataname: { private$dataname }")

          # this observer is needed in the situation when private$selected has been
          # changed directly by the api - then it's needed to rerender UI element
          # to show relevant values
          private$observers$seletion_api <- observeEvent(
            ignoreNULL = TRUE, # dates needs to be selected
            ignoreInit = TRUE,
            eventExpr = self$get_selected(),
            handlerExpr = {
              if (!setequal(self$get_selected(), input$selection)) {
                updateDateRangeInput(
                  session = session,
                  inputId = "selection",
                  start = self$get_selected()[1],
                  end = self$get_selected()[2]
                )
                logger::log_trace(sprintf(
                  "DateFilterState$server@1 selection of variable %s changed, dataname: %s",
                  private$varname,
                  private$dataname
                ))
              }
            }
          )

          private$observers$selection <- observeEvent(
            ignoreNULL = TRUE, # dates needs to be selected
            ignoreInit = TRUE, # ignoreInit: should not matter because we set the UI with the desired initial state
            eventExpr = input$selection,
            handlerExpr = {
              start_date <- input$selection[1]
              end_date <- input$selection[2]

              iv <- shinyvalidate::InputValidator$new()
              iv$add_rule("selection", ~ if (
                start_date > end_date
              ) {
                "Start date must not be greater than the end date."
              })
              iv$enable()
              teal::validate_inputs(iv)

              self$set_selected(c(start_date, end_date))
              logger::log_trace(sprintf(
                "DateFilterState$server@2 selection of variable %s changed, dataname: %s",
                private$varname,
                private$dataname
              ))
            }
          )


          private$keep_na_srv("keep_na")

          private$observers$reset1 <- observeEvent(input$start_date_reset, {
            updateDateRangeInput(
              session = session,
              inputId = "selection",
              start = private$choices[1]
            )
            logger::log_trace(sprintf(
              "DateFilterState$server@3 reset start date of variable %s, dataname: %s",
              private$varname,
              private$dataname
            ))
          })

          private$observers$reset2 <- observeEvent(input$end_date_reset, {
            updateDateRangeInput(
              session = session,
              inputId = "selection",
              end = private$choices[2]
            )
            logger::log_trace(sprintf(
              "DateFilterState$server@4 reset end date of variable %s, dataname: %s",
              private$varname,
              private$dataname
            ))
          })

          observeEvent(private$is_disabled(), {
            shinyjs::toggleState(
              id = "selection",
              condition = !private$is_disabled()
            )
            shinyjs::toggleState(
              id = "keep_na-value",
              condition = !private$is_disabled()
            )
          })

          logger::log_trace("DateFilterState$server initialized, dataname: { private$dataname }")
          NULL
        }
      )
    },
    # @description
    # Server module to display filter summary
    #  renders text describing selected date range and
    #  if NA are included also
    content_summary = function(id) {
      selected <- as.character(self$get_selected())
      min <- selected[1]
      max <- selected[2]
      tagList(
        tags$span(paste0(min, " - ", max)),
        if (self$get_keep_na()) tags$span("NA") else NULL
      )
    }
  )
)
