#' @name FilterStateExpr
#' @docType class
#'
#'
#' @title `FilterStateExpr` Class
#'
#' @description Class to handle filter expression.
#'
#'
#' @details
#' This class is responsible for displaying filter card and returning filter expression
#'
#' @keywords internal
#'
FilterStateExpr <- R6::R6Class( # nolint
  classname = "FilterStateExpr",
  # public methods ----
  public = list(
    #' @description
    #' Initialize a `FilterStateExpr` object
    #' @param dataname (`character(1)`)\cr
    #'   name of the dataset where `expr` could be executed on.
    #' @param expr (`character(1)`)\cr
    #' @param id (`character(1)`)\cr
    #'   identifier of the filter
    #' @param title (`character(1)`)\cr
    #'   title of the filter
    #'   logical expression written in executable way. By "executable" means
    #'   that `subset` call should be able to evaluate this without failure. For
    #'   example `MultiAssayExperiment::subsetByColData` requires variable names prefixed
    #'   by `dataname` (e.g. `data$var1 == "x" & data$var2 > 0`). For `data.frame` call
    #'   can be written without prefixing `var1 == "x" & var2 > 0`.
    #' @param disabled (`logical(1)`)\cr
    #'   flag specifying whether the `FilterState` is initiated disabled
    #' @param locked (`logical(1)`) \cr
    #'   flag specifying whether the `FilterState` is initiated locked
    #' @param ... additional arguments to be saved as a list in `private$extras` field
    #' @examples
    #' filter_state <- teal.slice:::FilterStateExpr$new(
    #'   dataname = "x",
    #'   id = "FA",
    #'   title = "Adult females",
    #'   expr = "sex == 'F' & age >= 18"
    #' )
    #' shiny::isolate(filter_state$get_call())
    #'
    #' \dontrun{
    #' # working filter in an app
    #' library(shiny)
    #' library(shinyjs)
    #'
    #' ui <- fluidPage(
    #'   useShinyjs(),
    #'   include_css_files(pattern = "filter-panel"),
    #'   include_js_files(pattern = "count-bar-labels"),
    #'   column(4, div(
    #'     h4("ChoicesFilterState"),
    #'     isolate(filter_state$ui("fs"))
    #'   )),
    #'   column(8, div(
    #'     h4("Condition (i.e. call)"), # display the subsetting call generated by this FilterState
    #'     textOutput("condition_choices"), br(),
    #'     h4("Unformatted state"), # display raw filter state
    #'     textOutput("unformatted_choices"), br(),
    #'     h4("Formatted state"), # display human readable filter state
    #'     textOutput("formatted_choices"), br()
    #'   ))
    #' )
    #'
    #' server <- function(input, output, session) {
    #'   filter_state$server("fs")
    #'   output$condition_choices <- renderPrint(filter_state$get_call())
    #'   output$formatted_choices <- renderText(filter_state$format())
    #'   output$unformatted_choices <- renderPrint(filter_state$get_state())
    #' }
    #'
    #' if (interactive()) {
    #'   shinyApp(ui, server)
    #' }
    #' }
    #'
    #' @return `FilterStateExpr`
    initialize = function(dataname, id, title, expr, disabled = FALSE, locked = FALSE, ...) {
      checkmate::assert_string(dataname)
      checkmate::assert_string(id)
      checkmate::assert_string(title)
      checkmate::assert_flag(disabled)
      checkmate::assert_flag(locked)
      checkmate::assert_string(expr)

      private$dataname <- dataname
      private$id <- id
      private$title <- title
      private$expr <- expr
      private$disabled <- reactiveVal(disabled)
      private$locked <- locked
      private$extras <- list(...)

      invisible(self)
    },

    #' @description
    #' Returns a formatted string representing this `FilterStateExpr` object.
    #'
    #' @param show_all `logical(1)` passed to `format.teal_slice`
    #'
    #' @return `character(1)` the formatted string
    #'
    format = function(show_all = FALSE) {
      sprintf(
        "%s:\n%s",
        class(self)[1],
        format(self$get_state(), show_all = show_all)
      )
    },

    #' @description
    #' Prints this `FilterStateExpr` object.
    #'
    #' @param ... additional arguments
    print = function(...) {
      cat(shiny::isolate(self$format(...)), "\n")
    },

    #' @description
    #' Returns filtering state.
    #'
    #' @return A `teal_slice` object.
    #'
    get_state = function() {
      states <- append(
        list(
          dataname = private$dataname,
          id = private$id,
          title = private$title,
          expr = private$expr,
          disabled = private$disabled(),
          locked = private$locked
        ),
        private$extras
      )
      do.call(filter_expr, states)
    },

    #' @description
    #' Sets filtering state.
    #'
    #' @param state a `teal_slice` object
    #'
    #' @return `self` invisibly
    #'
    set_state = function(state) {
      checkmate::assert_class(state, "teal_slice_expr")
      if (isTRUE(private$locked)) {
        logger::log_warn("attempt to disable a locked filter aborted: { private$dataname } { private$varname }")
      } else {
        if (isTRUE(state$disabled) && isFALSE(private$is_disabled())) private$disabled(TRUE)
        if (isFALSE(state$disabled) && isTRUE(private$is_disabled())) private$disabled(FALSE)
      }
      invisible(NULL)
    },

    #' @description
    #' Get reproducible call
    #'
    #' @param dataname (`ignored`) for a consistency with `FilterState`
    #'
    #' Returns reproducible condition call for current selection relevant
    #' for selected variable type.
    #' Method is using internal reactive values which makes it reactive
    #' and must be executed in reactive or isolated context.
    #' @return `language`
    get_call = function(dataname) {
      if (isTRUE(private$is_disabled())) {
        return(NULL)
      }
      str2lang(private$expr)
    },

    #' @description
    #' Destroy observers stored in `private$observers`.
    #'
    #' @return NULL invisibly
    #'
    destroy_observers = function() {
      lapply(private$observers, function(x) x$destroy())
      invisible(NULL)
    },

    # public shiny modules ----

    #' @description
    #' Shiny module server.
    #'
    #' @param id (`character(1)`)\cr
    #'   shiny module instance id
    #'
    #' @return `moduleServer` function which returns reactive value
    #'   signaling that remove button has been clicked
    #'
    server = function(id) {
      moduleServer(
        id = id,
        function(input, output, session) {
          private$server_summary("summary")

          # Disable/enable this filter state in response to switch flip.
          private$observers$is_disabled <- observeEvent(input$enable,
            {
              if (isTRUE(input$enable)) {
                private$disabled(FALSE)
              } else {
                private$disabled(TRUE)
              }
            },
            ignoreInit = TRUE
          )

          # Update disable switch according to disabled state.
          # This is necessary to react to the global disable action.
          private$observers$is_disabled <- observeEvent(private$is_disabled(), {
            if (isTRUE(private$is_disabled())) {
              shinyWidgets::updateSwitchInput(inputId = "enable", value = FALSE)
            }
            if (isFALSE(private$is_disabled())) {
              shinyWidgets::updateSwitchInput(inputId = "enable", value = TRUE)
            }
          })
          out <- reactive(input$remove) # back to parent to remove self
          out
        }
      )
    },

    #' @description
    #' Shiny module UI.
    #'
    #' @param id (`character(1)`)\cr
    #'  shiny element (module instance) id;
    #'  the UI for this class contains simple message stating that it is not supported
    #' @param parent_id (`character(1)`) id of the `FilterStates` card container
    ui = function(id, parent_id = "cards") {
      ns <- NS(id)

      tags$div(
        id = id,
        class = "panel filter-card",
        include_js_files("count-bar-labels.js"),
        tags$div(
          class = "filter-card-header",
          tags$div(
            class = "filter-card-title",
            icon("lock"),
            tags$span(tags$strong(private$id)),
            tags$span(private$title, class = "filter-card-varlabel")
          ),
          tags$div(
            class = "filter-card-controls",
            shinyWidgets::prettySwitch(
              ns("enable"),
              label = "",
              status = "success",
              fill = TRUE,
              value = shiny::isolate(!private$is_disabled()),
              width = 30
            ),
            actionLink(
              inputId = ns("remove"),
              label = icon("circle-xmark", lib = "font-awesome"),
              class = "filter-card-remove"
            )
          ),
          tags$div(
            class = "filter-card-summary",
            private$ui_summary(ns("summary"))
          )
        )
      )
    }
  ),

  # private members ----

  private = list(
    dataname = character(0),
    id = character(0),
    expr = NULL,
    title = character(0),
    disabled = NULL,
    locked = logical(0),
    extras = list(),
    observers = list(),

    # private methods ----

    # Check whether this filter is disabled
    # @return `logical(1)`
    is_disabled = function() {
      if (shiny::isRunning()) {
        isTRUE(private$disabled())
      } else {
        shiny::isolate(isTRUE(private$disabled()))
      }
    },
    content_summary = function() {
      private$expr
    },

    # shiny modules ----

    # @description
    # Server module to display filter summary
    # @param id `shiny` id parameter
    ui_summary = function(id) {
      ns <- NS(id)
      uiOutput(ns("summary"), class = "filter-card-summary")
    },

    # @description
    # UI module to display filter summary
    # @param shiny `id` parametr passed to moduleServer
    #  renders text describing current state
    server_summary = function(id) {
      moduleServer(
        id = id,
        function(input, output, session) {
          output$summary <- renderUI({
            if (private$is_disabled()) {
              tags$span("Disabled")
            } else {
              private$content_summary()
            }
          })
        }
      )
    }
  )
)
