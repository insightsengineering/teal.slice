#' @name RangeFilterState
#' @title `FilterState` object for numeric variable
#' @description Manages choosing a numeric range
#' @docType class
#' @keywords internal
#'
#'
#' @examples
#' filter_state <- teal.slice:::RangeFilterState$new(
#'   x = c(NA, Inf, seq(1:10)),
#'   varname = "x",
#'   dataname = "data",
#'   extract_type = character(0)
#' )
#' shiny::isolate(filter_state$get_call())
#' filter_state$set_state(
#'   filter_var(
#'     dataname = "data",
#'     varname = "x",
#'     selected = c(3L, 8L),
#'     keep_na = TRUE,
#'     keep_inf = TRUE
#'   )
#' )
#' shiny::isolate(filter_state$get_call())
#'
#' \dontrun{
#' # working filter in an app
#' library(shiny)
#' library(shinyjs)
#'
#' data_range <- c(runif(100, 0, 1), NA, Inf)
#' fs <- teal.slice:::RangeFilterState$new(
#'   x = data_range,
#'   dataname = "data",
#'   varname = "x",
#'   selected = c(0.15, 0.93),
#'   keep_na = TRUE,
#'   keep_inf = TRUE
#' )
#'
#' ui <- fluidPage(
#'   useShinyjs(),
#'   include_css_files(pattern = "filter-panel"),
#'   include_js_files(pattern = "count-bar-labels"),
#'   column(4, div(
#'     h4("RangeFilterState"),
#'     fs$ui("fs")
#'   )),
#'   column(4, div(
#'     id = "outputs", # div id is needed for toggling the element
#'     h4("Condition (i.e. call)"), # display the subsetting call generated by this FilterState
#'     textOutput("condition_range"), br(),
#'     h4("Unformatted state"), # display raw filter state
#'     textOutput("unformatted_range"), br(),
#'     h4("Formatted state"), # display human readable filter state
#'     textOutput("formatted_range"), br()
#'   )),
#'   column(4, div(
#'     h4("Programmatic filter control"),
#'     actionButton("button1_range", "set drop NA", width = "100%"), br(),
#'     actionButton("button2_range", "set keep NA", width = "100%"), br(),
#'     actionButton("button3_range", "set drop Inf", width = "100%"), br(),
#'     actionButton("button4_range", "set keep Inf", width = "100%"), br(),
#'     actionButton("button5_range", "set a range", width = "100%"), br(),
#'     actionButton("button6_range", "set full range", width = "100%"), br(),
#'     actionButton("button0_range", "set initial state", width = "100%"), br()
#'   ))
#' )
#'
#' server <- function(input, output, session) {
#'   fs$server("fs")
#'   output$condition_range <- renderPrint(fs$get_call())
#'   output$formatted_range <- renderText(fs$format())
#'   output$unformatted_range <- renderPrint(fs$get_state())
#'   # modify filter state programmatically
#'   observeEvent(
#'     input$button1_range,
#'     fs$set_state(filter_var(dataname = "data", varname = "x", keep_na = FALSE))
#'   )
#'   observeEvent(
#'     input$button2_range,
#'     fs$set_state(filter_var(dataname = "data", varname = "x", keep_na = TRUE))
#'   )
#'   observeEvent(
#'     input$button3_range,
#'     fs$set_state(filter_var(dataname = "data", varname = "x", keep_inf = FALSE))
#'   )
#'   observeEvent(
#'     input$button4_range,
#'     fs$set_state(filter_var(dataname = "data", varname = "x", keep_inf = TRUE))
#'   )
#'   observeEvent(
#'     input$button5_range,
#'     fs$set_state(
#'       filter_var(dataname = "data", varname = "x", selected = c(0.2, 0.74))
#'     )
#'   )
#'   observeEvent(
#'     input$button6_range,
#'     fs$set_state(filter_var(dataname = "data", varname = "x", selected = c(0, 1)))
#'   )
#'   observeEvent(
#'     input$button0_range,
#'     fs$set_state(
#'       filter_var("data", "variable", selected = c(0.15, 0.93), keep_na = TRUE, keep_inf = TRUE)
#'     )
#'   )
#' }
#'
#' if (interactive()) {
#'   shinyApp(ui, server)
#' }
#' }
#'
RangeFilterState <- R6::R6Class( # nolint
  "RangeFilterState",
  inherit = FilterState,

  # public methods ----
  public = list(

    #' @description
    #' Initialize a `FilterState` object for range selection
    #' @param x (`numeric`)\cr
    #'   values of the variable used in filter
    #' @param x_reactive (`reactive`)\cr
    #'   returning vector of the same type as `x`. Is used to update
    #'   counts following the change in values of the filtered dataset.
    #'   If it is set to `reactive(NULL)` then counts based on filtered
    #'   dataset are not shown.
    #' @param dataname (`character(1)`)\cr
    #'   optional name of dataset where `x` is taken from. Must be specified
    #'   if `extract_type` argument is not empty.
    #' @param varname (`character(1)`)\cr
    #'   name of the variable.
    #' @param choices (`atomic`, `NULL`)\cr
    #'   vector specifying allowed selection values
    #' @param selected (`atomic`, `NULL`)\cr
    #'   vector specifying selection
    #' @param keep_na (`logical(1)`, `NULL`)\cr
    #'   flag specifying whether to keep missing values
    #' @param keep_inf (`logical(1)`, `NULL`)\cr
    #'   flag specifying whether to keep infinite values
    #' @param fixed (`logical(1)`)\cr
    #'   flag specifying whether the `FilterState` is initiated fixed
    #' @param disabled (`logical(1)`)\cr
    #'   flag specifying whether the `FilterState` is initiated disabled
    #' @param extract_type (`character(0)`, `character(1)`)\cr
    #' whether condition calls should be prefixed by dataname. Possible values:
    #' \itemize{
    #' \item{`character(0)` (default)}{ `varname` in the condition call will not be prefixed}
    #' \item{`"list"`}{ `varname` in the condition call will be returned as `<dataname>$<varname>`}
    #' \item{`"matrix"`}{ `varname` in the condition call will be returned as `<dataname>[, <varname>]`}
    #' }
    #' @param ... additional arguments to be saved as a list in `private$extras` field
    #'
    initialize = function(x,
                          x_reactive = reactive(NULL),
                          dataname,
                          varname,
                          choices = NULL,
                          selected = NULL,
                          keep_na = NULL,
                          keep_inf = NULL,
                          fixed = FALSE,
                          disabled = FALSE,
                          extract_type = character(0),
                          ...) {
      checkmate::assert_numeric(x, all.missing = FALSE)
      checkmate::assert_numeric(choices, null.ok = TRUE)
      checkmate::assert_class(x_reactive, "reactive")
      if (!any(is.finite(x))) stop("\"x\" contains no finite values")

      keep_inf <- if (is.null(keep_inf) && any(is.infinite(x))) TRUE else keep_inf

      args <- list(
        x = x,
        x_reactive = x_reactive,
        dataname = dataname,
        varname = varname,
        keep_na = keep_na,
        keep_inf = keep_inf,
        fixed = fixed,
        disabled = disabled,
        extract_type = extract_type
      )
      args <- append(args, list(...))
      do.call(super$initialize, args)

      private$is_integer <- checkmate::test_integerish(x)
      private$inf_filtered_count <- reactive(
        if (!is.null(private$x_reactive())) sum(is.infinite(private$x_reactive()))
      )
      private$inf_count <- sum(is.infinite(x))

      private$set_choices(choices)
      private$set_selected(selected)

      invisible(self)
    },

    #' @description
    #' Returns a formatted string representing this `RangeFilterState`.
    #'
    #' @param indent (`numeric(1)`)
    #'        the number of spaces before after each new line character of the formatted string.
    #'        Default: 0
    #' @return `character(1)` the formatted string
    #'
    format = function(indent = 2) {
      checkmate::assert_number(indent, finite = TRUE, lower = 0)

      vals <- private$get_selected()
      sprintf(
        "%sFiltering on: %s\n%sSelected range: %s - %s\n%sInclude missing values: %s",
        format("", width = indent),
        private$varname,
        format("", width = indent * 2),
        format(vals[1], nsmall = 3),
        format(vals[2], nsmall = 3),
        format("", width = indent * 2),
        format(private$get_keep_na())
      )
    },

    #' @description
    #' Returns reproducible condition call for current selection.
    #' For this class returned call looks like
    #' `<varname> >= <min value> & <varname> <= <max value>` with
    #' optional `is.na(<varname>)` and `is.finite(<varname>)`.
    #' @param dataname name of data set; defaults to `private$dataname`
    #' @return (`call`)
    #'
    get_call = function(dataname) {
      if (isFALSE(private$is_any_filtered())) {
        return(NULL)
      }
      if (missing(dataname)) dataname <- private$dataname
      filter_call <-
        call(
          "&",
          call(">=", private$get_varname_prefixed(dataname), private$get_selected()[1L]),
          call("<=", private$get_varname_prefixed(dataname), private$get_selected()[2L])
        )
      private$add_keep_na_call(private$add_keep_inf_call(filter_call, dataname), dataname)
    },

    #' @description
    #' Returns current `keep_inf` selection
    #' @return (`logical(1)`)
    get_keep_inf = function() {
      private$keep_inf()
    }
  ),

  # private fields----
  private = list(
    inf_count = integer(0),
    inf_filtered_count = NULL,
    is_integer = logical(0),
    slider_step = numeric(0), # step for the slider input widget, calculated from input data (x)
    slider_ticks = numeric(0), # allowed values for the slider input widget, calculated from input data (x)

    # private methods ----

    set_choices = function(choices) {
      x <- private$x[is.finite(private$x)]
      if (is.null(choices)) {
        choices <- range(x)
      } else {
        choices_adjusted <- c(max(choices[1L], min(x)), min(choices[2L], max(x)))
        if (any(choices != choices_adjusted)) {
          warning(sprintf(
            "Choices adjusted (some values outside of variable range). Varname: %s, dataname: %s.",
            private$varname, private$dataname
          ))
          choices <- choices_adjusted
        }
        if (choices[1L] > choices[2L]) {
          warning(sprintf(
            "Invalid choices: lower is higher / equal to upper, or not in range of variable values.
            Setting defaults. Varname: %s, dataname: %s.",
            private$varname, private$dataname
          ))
          choices <- range(x)
        }
      }

      private$set_is_choice_limited(private$x, choices)
      private$x <- private$x[
        (private$x >= choices[1L] & private$x <= choices[2L]) | is.na(private$x) | !is.finite(private$x)
      ]

      x_range <- range(private$x, finite = TRUE)

      # Required for displaying ticks on the slider, can modify choices!
      if (identical(diff(x_range), 0)) {
        choices <- x_range
        private$slider_ticks <- signif(x_range, digits = 10)
        private$slider_step <- NULL
      } else {
        x_pretty <- pretty(x_range, 100L)
        choices <- range(x_pretty)
        private$slider_ticks <- signif(x_pretty, digits = 10)
        private$slider_step <- signif(private$get_pretty_range_step(x_pretty), digits = 10)
      }
      private$choices <- choices
      invisible(NULL)
    },

    # @description
    # Check whether the initial choices filter out some values of x and set the flag in case.
    set_is_choice_limited = function(xl, choices) {
      xl <- xl[!is.na(xl)]
      xl <- xl[is.finite(xl)]
      private$is_choice_limited <- (any(xl < choices[1L]) | any(xl > choices[2L]))
      invisible(NULL)
    },

    # Adds is.infinite(varname) before existing condition calls if keep_inf is selected
    # returns a call
    add_keep_inf_call = function(filter_call, dataname) {
      if (isTRUE(private$get_keep_inf())) {
        call("|", call("is.infinite", private$get_varname_prefixed(dataname)), filter_call)
      } else {
        filter_call
      }
    },

    # @description gets pretty step size for range slider
    #  adaptation of shiny's method (see shiny/R/input-slider.R function findStepSize)
    # @param pretty_range (numeric(n)) vector of pretty values
    # @return numeric(1) pretty step size for the sliderInput
    get_pretty_range_step = function(pretty_range) {
      if (private$is_integer && diff(range(pretty_range) > 2)) {
        return(1L)
      } else {
        n_steps <- length(pretty_range) - 1
        return(
          signif(digits = 10, (max(pretty_range) - min(pretty_range)) / n_steps)
        )
      }
    },

    # overwrites superclass method
    validate_selection = function(value) {
      if (!is.numeric(value)) {
        stop(
          sprintf(
            "value of the selection for `%s` in `%s` should be a numeric",
            private$get_varname(),
            private$get_dataname()
          )
        )
      }
      invisible(NULL)
    },

    # overwrites superclass method
    # additionally adjusts progtammatic selection to existing slider ticks
    cast_and_validate = function(values) {
      if (!is.atomic(values)) stop("Values to set must be an atomic vector.")
      values <- as.numeric(values)
      if (any(is.na(values))) stop("The array of set values must contain values coercible to numeric.")
      if (length(values) != 2) stop("The array of set values must have length two.")

      values_adjusted <- contain_interval(values, private$slider_ticks)
      if (!isTRUE(all.equal(values, values_adjusted))) {
        logger::log_warn(sprintf(
          paste(
            "Programmatic range specification on %s was adjusted to existing slider ticks.",
            "It is now broader in order to contain the specified values."
          ),
          private$varname
        ))
      }
      values_adjusted
    },
    # for numeric ranges selecting out of bound values is allowed
    remove_out_of_bound_values = function(values) {
      values
    },

    # Answers the question of whether the current settings and values selected actually filters out any values.
    # @return logical scalar
    is_any_filtered = function() {
      if (private$is_disabled()) {
        FALSE
      } else if (private$is_choice_limited) {
        TRUE
      } else if (!isTRUE(all.equal(private$get_selected(), private$choices))) {
        TRUE
      } else if (!isTRUE(private$get_keep_inf()) && private$inf_count > 0) {
        TRUE
      } else if (!isTRUE(private$get_keep_na()) && private$na_count > 0) {
        TRUE
      } else {
        FALSE
      }
    },

    # obtain shape determination for histogram
    get_shape_properties = function(values) {
      list(
        list(type = "line", x0 = values[1], x1 = values[1], y0 = -5, y1 = 5, yref = "paper"),
        list(type = "line", x0 = values[2], x1 = values[2], y0 = -5, y1 = 5, yref = "paper")
      )
    },

    # shiny modules ----

    # UI Module for `RangeFilterState`.
    # This UI element contains two values for `min` and `max`
    # of the range and two checkboxes whether to keep the `NA` or `Inf`  values.
    # @param id (`character(1)`)\cr
    #  id of shiny element
    ui_inputs = function(id) {
      ns <- NS(id)

      ui_input_manual <- shinyWidgets::numericRangeInput(
        inputId = ns("selection_manual"),
        label = NULL,
        min = private$choices[1L],
        max = private$choices[2L],
        value = shiny::isolate(private$selected()),
        step = private$slider_step,
        width = "100%"
      )

      if (shiny::isolate(private$is_disabled())) {
        ui_input_manual <- shinyjs::disabled(ui_input_manual)
      }

      tagList(
        div(
          class = "choices_state",
          plotly::plotlyOutput(ns("plot"), height = "50px")
        ),
        ui_input_manual,
        div(
          class = "filter-card-body-keep-na-inf",
          private$keep_inf_ui(ns("keep_inf")),
          private$keep_na_ui(ns("keep_na"))
        )
      )
    },

    # @description
    # Server module
    # @param id (`character(1)`)\cr
    #   an ID string that corresponds with the ID used to call the module's UI function.
    # return `moduleServer` function which returns `NULL`
    server_inputs = function(id) {
      moduleServer(
        id = id,
        function(input, output, session) {
          logger::log_trace("RangeFilterState$server initializing, dataname: { private$dataname }")

          plot_data <- list(
            x = Filter(Negate(is.na), Filter(is.finite, private$x)),
            type = "histogram",
            bingroup = 1,
            showlegend = FALSE,
            hoverinfo = "none",
            source = session$ns("histogram_plot")
          )
          plot_mask <- list(list(
            type = "rect", fillcolor = rgb(1, 1, 1, .65), line = list(width = 0),
            x0 = -0.5, x1 = 1.5, y0 = -0.5, y1 = 1.5, xref = "paper", yref = "paper"
          ))
          plot_layout <- reactive({
            shapes <- private$get_shape_properties(private$get_selected())
            if (private$is_disabled()) shapes <- c(shapes, plot_mask)
            list(
              barmode = "overlay",
              xaxis = list(showticklabels = TRUE, rangeslider = list(thickness = 0)),
              yaxis = list(showgrid = FALSE, showticklabels = FALSE),
              margin = list(b = 10, l = 5, r = 5, t = 5),
              plot_bgcolor = "#FFFFFF00",
              paper_bgcolor = "#FFFFFF00",
              shapes = shapes
            )
          })
          plot_config <- reactive({
            list(
              displayModeBar = FALSE,
              edits = list(shapePosition = TRUE),
              staticPlot = private$is_disabled()
            )
          })

          # display histogram, adding a second trace that contains filtered data
          finite_values <- reactive(Filter(is.finite, private$x_reactive()))
          output$plot <- plotly::renderPlotly({
            unfiltered_histogram <- do.call(plotly::plot_ly, plot_data)
            unfiltered_histogram <- do.call(plotly::layout, c(list(p = unfiltered_histogram), plot_layout()))
            unfiltered_histogram <- do.call(plotly::config, c(list(p = unfiltered_histogram), plot_config()))

            if (is.null(finite_values())) {
              unfiltered_histogram
            } else {
              plotly::add_histogram(p = unfiltered_histogram, x = finite_values(), bingroup = 1)
            }
          })

          # dragging shapes (lines) on plot updates selection
          private$observers$relayout <-
            observeEvent(
              ignoreNULL = FALSE,
              ignoreInit = TRUE,
              eventExpr = plotly::event_data("plotly_relayout", source = session$ns("histogram_plot")),
              handlerExpr = {
                event <- plotly::event_data("plotly_relayout", source = session$ns("histogram_plot"))
                if (any(grepl("shapes", names(event)))) {
                  line_positions <- private$get_selected()
                  if (any(grepl("shapes[0]", names(event), fixed = TRUE))) {
                    line_positions[1] <- event[["shapes[0].x0"]]
                  } else if (any(grepl("shapes[1]", names(event), fixed = TRUE))) {
                    line_positions[2] <- event[["shapes[1].x0"]]
                  }
                  if (line_positions[1] > line_positions[2]) {
                    showNotification(
                      "Numeric range start value must be less than end value.",
                      type = "warning"
                    )
                    plotly::plotlyProxyInvoke(
                      plotly::plotlyProxy("plot", deferUntilFlush = FALSE),
                      "relayout",
                      shapes = private$get_shape_properties(private$get_selected())
                    )
                    return(NULL)
                  }

                  private$set_selected(line_positions)
                }
              }
            )

          # change in selection updates shapes (lines) on plot and numeric input
          private$observers$selection_api <-
            observeEvent(
              ignoreNULL = FALSE,
              ignoreInit = TRUE,
              eventExpr = private$get_selected(),
              handlerExpr = {
                logger::log_trace(
                  sprintf(
                    "RangeFilterState$server@2 state of %s changed, dataname: %s",
                    private$get_varname(),
                    private$dataname
                  )
                )
                plotly::plotlyProxyInvoke(
                  plotly::plotlyProxy("plot"),
                  "relayout",
                  shapes = private$get_shape_properties(private$get_selected())
                )
                shinyWidgets::updateNumericRangeInput(
                  session = session,
                  inputId = "selection_manual",
                  value = private$get_selected()
                )
              }
            )

          # manual input updates selection
          private$observers$selection_manual <- observeEvent(
            ignoreNULL = FALSE,
            ignoreInit = TRUE,
            eventExpr = input$selection_manual,
            handlerExpr = {
              # 2 separate checks are required here to prevent errors
              #
              # if the user sets either input to 'e' it will return NA
              # this NA would cause the lower > upper check to return NA
              #  and the if(lower > upper) check would throw an error
              #
              # if lower > manual, contain_interval() will error because it
              #  expects it's input to be sorted
              if (any(is.na(input$selection_manual))) {
                showNotification(
                  "Numeric range values must be numbers.",
                  type = "warning"
                )
                shinyWidgets::updateNumericRangeInput(
                  session = session,
                  inputId = "selection_manual",
                  value = private$get_selected()
                )
                return(NULL)
              }
              if (input$selection_manual[1] > input$selection_manual[2]) {
                showNotification(
                  "Numeric range start value must be less than end value.",
                  type = "warning"
                )
                shinyWidgets::updateNumericRangeInput(
                  session = session,
                  inputId = "selection_manual",
                  value = private$get_selected()
                )
                return(NULL)
              }
              logger::log_trace(
                sprintf(
                  "RangeFilterState$server@3 selection of variable %s changed, dataname: %s",
                  private$varname,
                  private$dataname
                )
              )
              if (!isTRUE(all.equal(input$selection_manual, private$get_selected()))) {
                private$set_selected(input$selection_manual)
              }
            }
          )

          private$keep_inf_srv("keep_inf")
          private$keep_na_srv("keep_na")

          observeEvent(private$is_disabled(), {
            shinyjs::toggleState(
              id = "selection",
              condition = !private$is_disabled()
            )
            shinyjs::toggleState(
              id = "selection_manual",
              condition = !private$is_disabled()
            )
            shinyWidgets::updateSwitchInput(
              session = session,
              inputId = "manual",
              disabled = private$is_disabled()
            )

            # recreate plot as a static object
            plotly::plotlyProxyInvoke(
              plotly::plotlyProxy("plot"),
              "react",
              data = plot_data,
              layout = plot_layout(),
              config = plot_config()
            )
          })

          logger::log_trace("RangeFilterState$server initialized, dataname: { private$dataname }")
          NULL
        }
      )
    },
    server_inputs_fixed = function(id) {
      moduleServer(
        id = id,
        function(input, output, session) {
          logger::log_trace("RangeFilterState$server initializing, dataname: { private$dataname }")

          unfiltered_histogram <-
            plotly::plot_ly(
              x = Filter(Negate(is.na), Filter(is.finite, private$x)),
              type = "histogram",
              bingroup = 1,
              showlegend = FALSE,
              hoverinfo = "none",
              source = session$ns("histogram_plot")
            ) %>%
            plotly::layout(
              barmode = "overlay",
              xaxis = list(showticklabels = TRUE, rangeslider = list(thickness = 0)),
              yaxis = list(showgrid = FALSE, showticklabels = FALSE),
              margin = list(b = 10, l = 5, r = 5, t = 5),
              plot_bgcolor = "#FFFFFF00",
              paper_bgcolor = "#FFFFFF00",
              shapes = private$get_shape_properties(shiny::isolate(private$get_selected()))
            ) %>%
            plotly::config(displayModeBar = FALSE, staticPlot = TRUE)

          finite_values <- reactive(Filter(is.finite, private$x_reactive()))
          output$plot <- plotly::renderPlotly({
            if (is.null(finite_values())) {
              unfiltered_histogram
            } else {
              plotly::add_histogram(p = unfiltered_histogram, x = finite_values(), bingroup = 1)
            }
          })

          output$selection <- renderUI({
            plotly::plotlyOutput(session$ns("plot"), height = "50px")
          })

          logger::log_trace("RangeFilterState$server initialized, dataname: { private$dataname }")
          NULL
        }
      )
    },

    # @description
    # Server module to display filter summary
    #  renders text describing selected range and
    #  if NA or Inf are included also
    # @return `shiny.tag` to include in the `ui_summary`
    content_summary = function() {
      fmt_selected <- format_range_for_summary(private$get_selected())
      min <- fmt_selected[1]
      max <- fmt_selected[2]
      tagList(
        tags$span(shiny::HTML(min, "&ndash;", max), class = "filter-card-summary-value"),
        tags$span(
          class = "filter-card-summary-controls",
          if (isTRUE(private$get_keep_na()) && private$na_count > 0) {
            tags$span(
              class = "filter-card-summary-na",
              "NA",
              shiny::icon("check")
            )
          } else if (isFALSE(private$get_keep_na()) && private$na_count > 0) {
            tags$span(
              class = "filter-card-summary-na",
              "NA",
              shiny::icon("xmark")
            )
          } else {
            NULL
          },
          if (isTRUE(private$get_keep_inf()) && private$inf_count > 0) {
            tags$span(
              class = "filter-card-summary-inf",
              "Inf",
              shiny::icon("check")
            )
          } else if (isFALSE(private$get_keep_inf()) && private$inf_count > 0) {
            tags$span(
              class = "filter-card-summary-inf",
              "Inf",
              shiny::icon("xmark")
            )
          } else {
            NULL
          }
        )
      )
    },

    # @description
    # module displaying input to keep or remove Inf in the FilterState call
    # @param id `shiny` id parameter
    #  renders checkbox input only when variable from which FilterState has
    #  been created has some Inf values.
    keep_inf_ui = function(id) {
      ns <- NS(id)

      if (private$inf_count > 0) {
        countmax <- private$na_count
        countnow <- isolate(private$filtered_na_count())
        ui_input <- checkboxInput(
          inputId = ns("value"),
          label = tags$span(
            id = ns("count_label"),
            make_count_text(
              label = "Keep Inf",
              countmax = countmax,
              countnow = countnow
            )
          ),
          value = isolate(private$get_keep_inf())
        )
        if (shiny::isolate(private$is_disabled())) ui_input <- shinyjs::disabled(ui_input)
        div(
          uiOutput(ns("trigger_visible"), inline = TRUE),
          ui_input
        )
      } else {
        NULL
      }
    },

    # @description
    # module to handle Inf values in the FilterState
    # @param shiny `id` parametr passed to moduleServer
    #  module sets `private$keep_inf` according to the selection.
    #  Module also updates a UI element if the `private$keep_inf` has been
    #  changed through the api
    keep_inf_srv = function(id) {
      moduleServer(id, function(input, output, session) {
        # 1. renderUI is used here as an observer which triggers only if output is visible
        #  and if the reactive changes - reactive triggers only if the output is visible.
        # 2. We want to trigger change of the labels only if reactive count changes (not underlying data)
        output$trigger_visible <- renderUI({
          updateCountText(
            inputId = "count_label",
            label = "Keep Inf",
            countmax = private$inf_count,
            countnow = private$inf_filtered_count()
          )
          NULL
        })

        # this observer is needed in the situation when private$keep_na has been
        # changed directly by the api - then it's needed to rerender UI element
        # to show relevant values
        private$observers$keep_inf_api <- observeEvent(
          ignoreNULL = TRUE, # its not possible for range that NULL is selected
          ignoreInit = TRUE, # ignoreInit: should not matter because we set the UI with the desired initial state
          eventExpr = private$get_keep_inf(),
          handlerExpr = {
            if (!setequal(private$get_keep_inf(), input$value)) {
              updateCheckboxInput(
                inputId = "value",
                value = private$get_keep_inf()
              )
            }
          }
        )

        private$observers$keep_inf <- observeEvent(
          ignoreNULL = TRUE, # it's not possible for range that NULL is selected
          ignoreInit = TRUE, # ignoreInit: should not matter because we set the UI with the desired initial state
          eventExpr = input$value,
          handlerExpr = {
            keep_inf <- input$value
            private$set_keep_inf(keep_inf)
            logger::log_trace(
              sprintf(
                "%s$server keep_inf of variable %s set to: %s, dataname: %s",
                class(self)[1],
                private$varname,
                input$value,
                private$dataname
              )
            )
          }
        )

        observeEvent(private$is_disabled(), {
          shinyjs::toggleState(
            id = "value",
            condition = !private$is_disabled()
          )
        })
        invisible(NULL)
      })
    }
  )
)
