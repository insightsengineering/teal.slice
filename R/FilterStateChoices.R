#' @name ChoicesFilterState
#' @title `FilterState` object for factor or character variable
#' @description Manages choosing elements from a set
#' @docType class
#' @keywords internal
#'
#'
#' @examples
#' filter_state <- teal.slice:::ChoicesFilterState$new(
#'   x = c(LETTERS, NA),
#'   varname = "x",
#'   dataname = "data"
#' )
#' shiny::isolate(filter_state$get_call())
#' shiny::isolate(
#'   filter_state$set_state(
#'     filter_var(
#'       dataname = "data",
#'       varname = "x",
#'       selected = "A",
#'       keep_na = TRUE
#'     )
#'   )
#' )
#' shiny::isolate(filter_state$get_call())
#'
#' \dontrun{
#' # working filter in an app
#' library(shiny)
#' library(shinyjs)
#'
#' data_choices <- c(sample(letters[1:4], 100, replace = TRUE), NA)
#' attr(data_choices, "label") <- "lowercase letters"
#' fs <- ChoicesFilterState$new(
#'   x = data_choices,
#'   dataname = "data",
#'   varname = "variable",
#'   selected = c("a", "b"),
#'   keep_na = TRUE
#' )
#'
#' ui <- fluidPage(
#'   useShinyjs(),
#'   include_css_files(pattern = "filter-panel"),
#'   include_js_files(pattern = "count-bar-labels"),
#'   column(4, div(
#'     h4("ChoicesFilterState"),
#'     fs$ui("fs")
#'   )),
#'   column(4, div(
#'     h4("Condition (i.e. call)"), # display the subsetting call generated by this FilterState
#'     textOutput("condition_choices"), br(),
#'     h4("Unformatted state"), # display raw filter state
#'     textOutput("unformatted_choices"), br(),
#'     h4("Formatted state"), # display human readable filter state
#'     textOutput("formatted_choices"), br()
#'   )),
#'   column(4, div(
#'     h4("Programmatic filter control"),
#'     actionButton("button1_choices", "set drop NA", width = "100%"), br(),
#'     actionButton("button2_choices", "set keep NA", width = "100%"), br(),
#'     actionButton("button3_choices", "set selection: a, b", width = "100%"), br(),
#'     actionButton("button4_choices", "deselect all", width = "100%"), br(),
#'     actionButton("button0_choices", "set initial state", width = "100%"), br()
#'   ))
#' )
#'
#' server <- function(input, output, session) {
#'   fs$server("fs")
#'   output$condition_choices <- renderPrint(fs$get_call())
#'   output$formatted_choices <- renderText(fs$format())
#'   output$unformatted_choices <- renderPrint(fs$get_state())
#'   # modify filter state programmatically
#'   observeEvent(
#'     input$button1_choices,
#'     fs$set_state(
#'       filter_var(dataname = "data", varname = "variable", keep_na = FALSE)
#'     )
#'   )
#'   observeEvent(
#'     input$button2_choices,
#'     fs$set_state(
#'       filter_var(dataname = "data", varname = "variable", keep_na = TRUE)
#'     )
#'   )
#'   observeEvent(
#'     input$button3_choices,
#'     fs$set_state(
#'       filter_var(dataname = "data", varname = "variable", selected = c("a", "b"))
#'     )
#'   )
#'   observeEvent(
#'     input$button4_choices,
#'     fs$set_state(
#'       filter_var("data", "variable", selected = character(0), keep_na = TRUE)
#'     )
#'   )
#'   observeEvent(
#'     input$button0_choices,
#'     fs$set_state(
#'       filter_var("data", "variable", selected = c("a", "c"), keep_na = TRUE)
#'     )
#'   )
#' }
#'
#' if (interactive()) {
#'   shinyApp(ui, server)
#' }
#' }
#'
ChoicesFilterState <- R6::R6Class( # nolint
  "ChoicesFilterState",
  inherit = FilterState,

  # public methods ----

  public = list(

    #' @description
    #' Initialize a `InteractiveFilterState` object
    #'
    #' @param x (`vector`)\cr
    #'   values of the variable used in filter
    #' @param x_reactive (`reactive`)\cr
    #'   returning vector of the same type as `x`. Is used to update
    #'   counts following the change in values of the filtered dataset.
    #'   If it is set to `reactive(NULL)` then counts based on filtered
    #'   dataset are not shown.
    #' @param dataname (`character(1)`)\cr
    #'   optional name of dataset where `x` is taken from. Must be specified
    #'   if `extract_type` argument is not empty.
    #' @param varname (`character(1)`)\cr
    #'   name of the variable.
    #' @param choices (`atomic`, `NULL`)\cr
    #'   vector specifying allowed selection values
    #' @param selected (`atomic`, `NULL`)\cr
    #'   vector specifying selection
    #' @param keep_na (`logical(1)`, `NULL`)\cr
    #'   flag specifying whether to keep missing values
    #' @param keep_inf (`logical(1)`, `NULL`)\cr
    #'   flag specifying whether to keep infinite values
    #' @param fixed (`logical(1)`)\cr
    #'   flag specifying whether the `FilterState` is initiated fixed
    #' @param disabled (`logical(1)`)\cr
    #'   flag specifying whether the `FilterState` is initiated disabled
    #' @param extract_type (`character(0)`, `character(1)`)\cr
    #' whether condition calls should be prefixed by dataname. Possible values:
    #' \itemize{
    #' \item{`character(0)` (default)}{ `varname` in the condition call will not be prefixed}
    #' \item{`"list"`}{ `varname` in the condition call will be returned as `<dataname>$<varname>`}
    #' \item{`"matrix"`}{ `varname` in the condition call will be returned as `<dataname>[, <varname>]`}
    #' }
    #' @param ... additional arguments to be saved as a list in `private$extras` field
    #'
    initialize = function(x,
                          x_reactive = reactive(NULL),
                          dataname,
                          varname,
                          choices = NULL,
                          selected = NULL,
                          keep_na = NULL,
                          keep_inf = NULL,
                          fixed = FALSE,
                          disabled = FALSE,
                          extract_type = character(0),
                          ...) {
      checkmate::assert(
        is.character(x),
        is.factor(x),
        length(unique(x[!is.na(x)])) < getOption("teal.threshold_slider_vs_checkboxgroup"),
        combine = "or"
      )

      x_factor <- if (!is.factor(x)) {
        structure(
          factor(as.character(x), levels = as.character(sort(unique(x)))),
          label = attr(x, "label")
        )
      } else {
        x
      }

      args <- list(
        x = x_factor,
        x_reactive = x_reactive,
        dataname = dataname,
        varname = varname,
        keep_na = keep_na,
        keep_inf = keep_inf,
        fixed = fixed,
        disabled = disabled,
        extract_type = extract_type
      )
      args <- append(args, list(...))
      do.call(super$initialize, args)

      private$set_choices(choices)
      private$set_selected(selected)

      private$data_class <- class(x)[1L]
      if (inherits(x, "POSIXt")) {
        private$tzone <- Find(function(x) x != "", attr(as.POSIXlt(x), "tzone"))
      }

      private$set_choices_counts(unname(table(x_factor)))

      invisible(self)
    },

    #' @description
    #' Returns reproducible condition call for current selection.
    #' For this class returned call looks like
    #' `<varname> %in%  c(<values selected>)` with
    #' optional `is.na(<varname>)`.
    #' @param dataname name of data set; defaults to `private$dataname`
    #' @return (`call`) or `NULL`
    #'
    get_call = function(dataname) {
      if (isFALSE(private$is_any_filtered())) {
        return(NULL)
      }
      if (missing(dataname)) dataname <- private$dataname
      varname <- private$get_varname_prefixed(dataname)
      choices <- private$get_selected()
      if (private$data_class != "factor") {
        choices <- do.call(sprintf("as.%s", private$data_class), list(x = choices))
      }
      fun_compare <- if (length(choices) == 1L) "==" else "%in%"

      # to return `c` call instead of a vector
      make_c_call <- function(choices) {
        if (length(choices) > 1) {
          do.call("call", append(list("c"), choices))
        } else {
          choices
        }
      }

      filter_call <-
        if (inherits(choices, "Date")) {
          call(fun_compare, varname, call("as.Date", make_c_call(as.character(choices))))
        } else if (inherits(choices, c("POSIXct", "POSIXlt"))) {
          class <- class(choices)[1L]
          date_fun <- as.name(
            switch(class,
              "POSIXct" = "as.POSIXct",
              "POSIXlt" = "as.POSIXlt"
            )
          )
          call(
            fun_compare,
            varname,
            as.call(list(date_fun, make_c_call(as.character(choices)), tz = private$tzone))
          )
        } else {
          # This handles numerics, characters, and factors.
          call(fun_compare, varname, make_c_call(choices))
        }
      private$add_keep_na_call(filter_call, dataname)
    }
  ),

  # private members ----

  private = list(
    x = NULL,
    choices_counts = integer(0),
    data_class = character(0), # stores class of filtered variable so that it can be restored in $get_call
    tzone = character(0), # if x is a datetime, stores time zone so that it can be restored in $get_call

    # private methods ----
    # @description
    # Checks validity of the choices, adjust if neccessary and sets the flag for the case where choices
    #  are limited by default from the start.
    set_choices = function(choices) {
      if (is.null(choices)) {
        choices <- levels(private$x)
      } else {
        choices <- as.character(choices)
        choices_adjusted <- choices[choices %in% private$x]
        if (length(setdiff(choices, choices_adjusted)) > 0L) {
          warning(sprintf(
            "Some of the choices not within variable values, adjusting. Varname: %s, dataname: %s.",
            private$varname, private$dataname
          ))
          choices <- choices_adjusted
        }
        if (length(choices) == 0) {
          warning(sprintf(
            "Invalid choices: none of them within the values in the variable.
            Setting defaults. Varname: %s, dataname: %s.",
            private$varname, private$dataname
          ))
          choices <- levels(private$x)
        }
      }
      private$set_is_choice_limited(private$x, choices)
      private$choices <- choices
      private$x <- private$x[(private$x %in% private$choices) | is.na(private$x)]
      private$x <- droplevels(private$x)
      invisible(NULL)
    },
    # @description
    # Check whether the initial choices filter out some values of x and set the flag in case.
    set_is_choice_limited = function(x, choices) {
      xl <- x[!is.na(x)]
      private$is_choice_limited <- length(setdiff(xl, choices)) > 0L
      invisible(NULL)
    },
    # @description
    # Sets choices_counts private field
    set_choices_counts = function(choices_counts) {
      private$choices_counts <- choices_counts
      invisible(NULL)
    },
    get_choices_counts = function() {
      if (!is.null(private$x_reactive)) {
        table(factor(private$x_reactive(), levels = private$choices))
      } else {
        NULL
      }
    },
    validate_selection = function(value) {
      if (!is.character(value)) {
        stop(
          sprintf(
            "Values of the selection for `%s` in `%s` should be an array of character.",
            private$get_varname(),
            private$get_dataname()
          )
        )
      }
      pre_msg <- sprintf(
        "data '%s', variable '%s': ",
        private$get_dataname(),
        private$get_varname()
      )
      check_in_subset(value, private$choices, pre_msg = pre_msg)
    },
    cast_and_validate = function(values) {
      tryCatch(
        expr = {
          values <- as.character(values)
          if (any(is.na(values))) stop()
        },
        error = function(error) stop("The array of set values must contain values coercible to character.")
      )
      values
    },
    remove_out_of_bound_values = function(values) {
      in_choices_mask <- values %in% private$choices
      if (length(values[!in_choices_mask]) > 0) {
        warning(paste(
          "Values:", strtrim(paste(values[!in_choices_mask], collapse = ", "), 360),
          "are not in choices of column", private$varname, "in dataset", private$dataname, "."
        ))
      }
      values[in_choices_mask]
    },
    is_checkboxgroup = function() {
      length(private$choices) <= getOption("teal.threshold_slider_vs_checkboxgroup")
    },

    # shiny modules ----

    # @description
    # UI Module for `ChoicesFilterState`.
    # This UI element contains available choices selection and
    # checkbox whether to keep or not keep the `NA` values.
    # @param id (`character(1)`)\cr
    #  id of shiny element
    ui_inputs = function(id) {
      ns <- NS(id)

      countsmax <- private$choices_counts
      countsnow <- if (!is.null(shiny::isolate(private$x_reactive()))) {
        isolate(unname(table(factor(shiny::isolate(private$x_reactive()), levels = private$choices))))
      } else {
        NULL
      }

      ui_input <- if (private$is_checkboxgroup()) {
        labels <- countBars(
          inputId = ns("labels"),
          choices = private$choices,
          countsnow = countsnow,
          countsmax = countsmax
        )
        div(
          class = "choices_state",
          checkboxGroupInput(
            inputId = ns("selection"),
            label = NULL,
            selected = shiny::isolate(private$selected()),
            choiceNames = labels,
            choiceValues = private$choices,
            width = "100%"
          )
        )
      } else {
        labels <- mapply(
          FUN = make_count_text,
          label = private$choices,
          countnow = if (is.null(countsnow)) rep(list(NULL), length(private$choices)) else countsnow,
          countmax = countsmax
        )

        teal.widgets::optionalSelectInput(
          inputId = ns("selection"),
          choices = stats::setNames(private$choices, labels),
          selected = shiny::isolate(private$get_selected()),
          multiple = TRUE,
          options = shinyWidgets::pickerOptions(
            actionsBox = TRUE,
            liveSearch = (length(private$choices) > 10),
            noneSelectedText = "Select a value"
          )
        )
      }
      if (shiny::isolate(private$is_disabled())) ui_input <- shinyjs::disabled(ui_input)
      div(
        uiOutput(ns("trigger_visible")),
        ui_input,
        private$keep_na_ui(ns("keep_na"))
      )
    },

    # @description
    # Server module
    # @param id (`character(1)`)\cr
    #   an ID string that corresponds with the ID used to call the module's UI function.
    # @return `moduleServer` function which returns `NULL`
    server_inputs = function(id) {
      moduleServer(
        id = id,
        function(input, output, session) {
          logger::log_trace("ChoicesFilterState$server initializing, dataname: { private$dataname }")

          # 1. renderUI is used here as an observer which triggers only if output is visible
          #  and if the reactive changes - reactive triggers only if the output is visible.
          # 2. We want to trigger change of the labels only if reactive count changes (not underlying data)
          non_missing_values <- reactive(Filter(Negate(is.na), private$x_reactive()))
          output$trigger_visible <- renderUI({
            logger::log_trace(sprintf(
              "ChoicesFilterState$server@1 updating count labels in variable: %s , dataname: %s",
              private$varname,
              private$dataname
            ))

            countsnow <- if (!is.null(private$x_reactive())) {
              unname(table(factor(non_missing_values(), levels = private$choices)))
            } else {
              NULL
            }

            if (private$is_checkboxgroup()) {
              updateCountBars(
                inputId = "labels",
                choices = private$choices,
                countsmax = private$choices_counts,
                countsnow = countsnow
              )
            } else {
              labels <- mapply(
                FUN = make_count_text,
                label = private$choices,
                countnow = if (is.null(countsnow)) rep(list(NULL), length(private$choices)) else countsnow,
                countmax = private$choices_counts
              )
              teal.widgets::updateOptionalSelectInput(
                session = session,
                inputId = "selection",
                choices = stats::setNames(private$choices, labels),
                selected = private$get_selected()
              )
            }
            NULL
          })

          if (private$is_checkboxgroup()) {
            private$observers$selection <- observeEvent(
              ignoreNULL = FALSE, # it's possible that nothing is selected
              ignoreInit = TRUE, # ignoreInit: should not matter because we set the UI with the desired initial state
              eventExpr = input$selection,
              handlerExpr = {
                logger::log_trace(sprintf(
                  "ChoicesFilterState$server@2 selection of variable %s changed, dataname: %s",
                  private$varname,
                  private$dataname
                ))
                selection <- if (is.null(input$selection)) character(0) else input$selection
                private$set_selected(selection)
              }
            )
          } else {
            private$observers$selection <- observeEvent(
              ignoreNULL = FALSE, # it's possible that nothing is selected
              ignoreInit = TRUE, # ignoreInit: should not matter because we set the UI with the desired initial state
              eventExpr = input$selection_open,
              handlerExpr = {
                if (!isTRUE(input$selection_open)) {
                  logger::log_trace(sprintf(
                    "ChoicesFilterState$server@2 selection of variable %s changed, dataname: %s",
                    private$varname,
                    private$dataname
                  ))
                  selection <- if (is.null(input$selection)) character(0) else input$selection
                  private$set_selected(selection)
                }
              }
            )
          }
          private$keep_na_srv("keep_na")

          # this observer is needed in the situation when private$selected has been
          # changed directly by the api - then it's needed to rerender UI element
          # to show relevant values
          private$observers$selection_api <- observeEvent(private$selected(), {
            if (!isTRUE(all.equal(input$selection, private$get_selected()))) {
              logger::log_trace(sprintf(
                "ChoicesFilterState$server@2 state of variable %s changed, dataname: %s",
                private$varname,
                private$dataname
              ))
              if (private$is_checkboxgroup()) {
                updateCheckboxGroupInput(
                  inputId = "selection",
                  selected = private$selected()
                )
              } else {
                teal.widgets::updateOptionalSelectInput(
                  session, "selection",
                  selected = private$selected()
                )
              }
            }
          })

          # private$observers$disabled_toggle_selection <- observeEvent(private$is_disabled(), {
          #   shinyjs::toggleState(
          #     id = "selection",
          #     condition = !private$is_disabled()
          #   )
          # })

          logger::log_trace("ChoicesFilterState$server initialized, dataname: { private$dataname }")
          NULL
        }
      )
    },
    server_inputs_fixed = function(id) {
      moduleServer(
        id = id,
        function(input, output, session) {
          logger::log_trace("ChoicesFilterState$server initializing, dataname: { private$dataname }")

          output$selection <- renderUI({
            countsnow <- unname(table(factor(private$x_reactive(), levels = private$choices)))
            countsmax <- private$choices_counts

            ind <- private$choices %in% shiny::isolate(private$selected())
            countBars(
              inputId = session$ns("labels"),
              choices = shiny::isolate(private$selected()),
              countsnow = countsnow[ind],
              countsmax = countsmax[ind]
            )
          })

          logger::log_trace("ChoicesFilterState$server initialized, dataname: { private$dataname }")
          NULL
        }
      )
    },

    # @description
    # UI module to display filter summary
    #  renders text describing number of selected levels
    #  and if NA are included also
    content_summary = function(id) {
      selected <- private$get_selected()
      selected_length <- nchar(paste0(selected, collapse = ""))
      if (selected_length <= 40) {
        selected_text <- paste0(selected, collapse = ", ")
      } else {
        n_selected <- length(selected)
        selected_text <- paste(n_selected, "levels selected")
      }
      tagList(
        tags$span(
          class = "filter-card-summary-value",
          selected_text
        ),
        tags$span(
          class = "filter-card-summary-controls",
          if (isTRUE(private$get_keep_na()) && private$na_count > 0) {
            tags$span(
              class = "filter-card-summary-na",
              "NA",
              shiny::icon("check")
            )
          } else if (isFALSE(private$get_keep_na()) && private$na_count > 0) {
            tags$span(
              class = "filter-card-summary-na",
              "NA",
              shiny::icon("xmark")
            )
          } else {
            NULL
          }
        )
      )
    }
  )
)
