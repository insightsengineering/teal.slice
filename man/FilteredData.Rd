% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FilteredData.R
\docType{class}
\name{FilteredData}
\alias{FilteredData}
\title{Class to encapsulate filtered datasets}
\description{
Class to encapsulate filtered datasets

Class to encapsulate filtered datasets
}
\details{
The main purpose of this class is to provide a collection of reactive datasets,
each dataset having a filter state that determines how it is filtered.

For each dataset, \code{get_filter_expr} returns the call to filter the dataset according
to the filter state. The data itself can be obtained through \code{get_data}.

The datasets are filtered lazily, i.e. only when requested / needed in a Shiny app.

By design, any \code{dataname} set through \code{set_dataset} cannot be removed because
other code may already depend on it. As a workaround, the underlying
data can be set to \code{NULL}.

The class currently supports variables of the following types within datasets:
\itemize{
\item \code{choices}: variable of type \code{factor}, e.g. \code{ADSL$COUNTRY}, \code{iris$Species}
zero or more options can be selected, when the variable is a factor
\item \code{logical}: variable of type \code{logical}, e.g. \code{ADSL$TRT_FLAG}
exactly one option must be selected, \code{TRUE} or \code{FALSE}
\item \code{ranges}: variable of type \code{numeric}, e.g. \code{ADSL$AGE}, \code{iris$Sepal.Length}
numerical range, a range within this range can be selected
\item \code{dates}: variable of type \code{Date}, \code{POSIXlt}
Other variables cannot be used for filtering the data in this class.
}

Common arguments are:
\enumerate{
\item \code{filtered}: whether to return a filtered result or not
\item \code{dataname}: the name of one of the datasets in this \code{FilteredData}
\item \code{varname}: one of the columns in a dataset
}
}
\examples{
library(shiny)
datasets <- teal.slice:::FilteredData$new()
datasets$set_dataset("iris", iris)
datasets$set_dataset("mtcars", mtcars)

# get datanames
isolate(datasets$datanames())

datasets$set_filter_state(
  teal_slices(teal_slice(dataname = "iris", varname = "Species", selected = "virginica"))
)
isolate(datasets$get_call("iris"))

datasets$set_filter_state(
  teal_slices(teal_slice(dataname = "mtcars", varname = "mpg", selected = c(15, 20)))
)

isolate(datasets$get_filter_state())
isolate(datasets$get_call("iris"))
isolate(datasets$get_call("mtcars"))


## ------------------------------------------------
## Method `FilteredData$set_filter_state`
## ------------------------------------------------

utils::data(miniACC, package = "MultiAssayExperiment")

datasets <- teal.slice:::FilteredData$new(list(iris = iris, mae = miniACC))

fs <-
  teal_slices(
    teal_slice(dataname = "iris", varname = "Sepal.Length", selected = c(5.1, 6.4),
               keep_na = TRUE, keep_inf = FALSE),
    teal_slice(dataname = "iris", varname = "Species", selected = c("setosa", "versicolor"),
               keep_na = FALSE),
    teal_slice(dataname = "mae", varname = "years_to_birth", selected = c(30, 50),
               keep_na = TRUE, keep_inf = FALSE),
    teal_slice(dataname = "mae", varname = "vital_status", selected = "1", keep_na = FALSE),
    teal_slice(dataname = "mae", varname = "gender", selected = "female", keep_na = TRUE),
    teal_slice(dataname = "mae", varname = "ARRAY_TYPE",
               selected = "", keep_na = TRUE, datalabel = "RPPAArray", arg = "subset")
  )
datasets$set_filter_state(state = fs)
shiny::isolate(datasets$get_filter_state())

}
\keyword{internal}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-FilteredData-new}{\code{FilteredData$new()}}
\item \href{#method-FilteredData-get_filter_state}{\code{FilteredData$get_filter_state()}}
\item \href{#method-FilteredData-set_filter_state}{\code{FilteredData$set_filter_state()}}
\item \href{#method-FilteredData-remove_filter_state}{\code{FilteredData$remove_filter_state()}}
\item \href{#method-FilteredData-clear_filter_states}{\code{FilteredData$clear_filter_states()}}
\item \href{#method-FilteredData-get_available_teal_slices}{\code{FilteredData$get_available_teal_slices()}}
\item \href{#method-FilteredData-set_available_teal_slices}{\code{FilteredData$set_available_teal_slices()}}
\item \href{#method-FilteredData-datanames}{\code{FilteredData$datanames()}}
\item \href{#method-FilteredData-set_dataset}{\code{FilteredData$set_dataset()}}
\item \href{#method-FilteredData-get_data}{\code{FilteredData$get_data()}}
\item \href{#method-FilteredData-get_call}{\code{FilteredData$get_call()}}
\item \href{#method-FilteredData-set_join_keys}{\code{FilteredData$set_join_keys()}}
\item \href{#method-FilteredData-get_join_keys}{\code{FilteredData$get_join_keys()}}
\item \href{#method-FilteredData-get_keys}{\code{FilteredData$get_keys()}}
\item \href{#method-FilteredData-state_list_get}{\code{FilteredData$state_list_get()}}
\item \href{#method-FilteredData-state_list_push}{\code{FilteredData$state_list_push()}}
\item \href{#method-FilteredData-state_list_remove}{\code{FilteredData$state_list_remove()}}
\item \href{#method-FilteredData-clone}{\code{FilteredData$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-new"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-new}{}}}
\subsection{Method \code{new()}}{
Initialize a \code{FilteredData} object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$new()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data_objects}}{(\code{list})
Named list of data objects.
Names of the list will serve as \code{dataname}.}

\item{\code{join_keys}}{(\code{join_keys} or NULL) see \code{\link[teal.data:join_keys]{teal.data::join_keys()}}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-get_filter_state"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-get_filter_state}{}}}
\subsection{Method \code{get_filter_state()}}{
Gets reactive values from active \code{FilterState} objects.

Get active filter state from \code{FilterState} objects stored in \code{state_list}(s).
The output is a list compatible with input to \code{self$set_filter_state}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_filter_state()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{list} containing \code{list} per \code{FilterState} in the \code{state_list}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-set_filter_state"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-set_filter_state}{}}}
\subsection{Method \code{set_filter_state()}}{
Sets active filter states.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_filter_state(state)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{(\code{teal_slices}) object}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{NULL} invisibly
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{utils::data(miniACC, package = "MultiAssayExperiment")

datasets <- teal.slice:::FilteredData$new(list(iris = iris, mae = miniACC))

fs <-
  teal_slices(
    teal_slice(dataname = "iris", varname = "Sepal.Length", selected = c(5.1, 6.4),
               keep_na = TRUE, keep_inf = FALSE),
    teal_slice(dataname = "iris", varname = "Species", selected = c("setosa", "versicolor"),
               keep_na = FALSE),
    teal_slice(dataname = "mae", varname = "years_to_birth", selected = c(30, 50),
               keep_na = TRUE, keep_inf = FALSE),
    teal_slice(dataname = "mae", varname = "vital_status", selected = "1", keep_na = FALSE),
    teal_slice(dataname = "mae", varname = "gender", selected = "female", keep_na = TRUE),
    teal_slice(dataname = "mae", varname = "ARRAY_TYPE",
               selected = "", keep_na = TRUE, datalabel = "RPPAArray", arg = "subset")
  )
datasets$set_filter_state(state = fs)
shiny::isolate(datasets$get_filter_state())

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-remove_filter_state"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-remove_filter_state}{}}}
\subsection{Method \code{remove_filter_state()}}{
Removes one or more \code{FilterState} from a \code{FilteredData} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$remove_filter_state(state)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{(\code{teal_slices})\cr
specifying \code{FilterState} objects to remove;
\code{teal_slice}s may contain only \code{dataname} and \code{varname}, other elements are ignored}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{NULL} invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-clear_filter_states"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-clear_filter_states}{}}}
\subsection{Method \code{clear_filter_states()}}{
Remove all \code{FilterState}(s) from the \code{FilteredData} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$clear_filter_states(datanames = self$datanames(), force = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{datanames}}{(\code{character})\cr
\code{datanames} to remove their \code{FilterState}(s). By default all datasets are cleared.}

\item{\code{force}}{(\code{logical(1)})\cr
to force removal of anchored filters.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{NULL} invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-get_available_teal_slices"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-get_available_teal_slices}{}}}
\subsection{Method \code{get_available_teal_slices()}}{
Get list of filter states available for this object.

All \code{teal_slice} objects that have been created since the beginning of the app session
are stored in one \code{teal_slices} object. This returns a subset of that \code{teal_slices},
describing filter states that can be set for this object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_available_teal_slices()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{reactive} that returns \code{teal_slices}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-set_available_teal_slices"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-set_available_teal_slices}{}}}
\subsection{Method \code{set_available_teal_slices()}}{
Set list of external filter states available for activation.

Unlike adding new filter from the column, these filters can come with some prespecified settings.
\code{teal_slices} are wrapped in a \code{reactive} so they can be updated from elsewhere in the app.
Filters passed in \code{x} are limited to those that can be set for this \code{FilteredData},
i.e. they have the correct \code{dataname} and \code{varname} (waived \code{teal_slice_fixed} as they do not have \code{varname}).
List is accessible in \code{ui/srv_active} through \code{ui/srv_available_filters}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_available_teal_slices(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{(\code{reactive})\cr
should return \code{teal_slices}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
invisible \code{NULL}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-datanames"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-datanames}{}}}
\subsection{Method \code{datanames()}}{
Gets \code{datanames}

The \code{datanames} are returned in the order in which they must be
evaluated (in case of dependencies).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$datanames()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
(\code{character} vector) of \code{datanames}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-set_dataset"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-set_dataset}{}}}
\subsection{Method \code{set_dataset()}}{
Adds a dataset to this \code{FilteredData}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_dataset(dataname, dataset)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{(\code{string})\cr
the name of the \code{dataset} to be added to this object}

\item{\code{dataset}}{(\code{data.frame}, \code{MultiAssayExperiment})\cr
data to be filtered.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
\code{set_dataset} adds a dataset to this \code{FilteredData} object and sets reactive components
for datasets' filtering. Data in the filter panel is filtered when:
\itemize{
\item filter call changes. Filter call is a product of all active \code{FilterState}(s).
\item When ancestors filtered data changes.
}
}

\subsection{Returns}{
(\code{self}) invisibly this \code{FilteredData}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-get_data"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-get_data}{}}}
\subsection{Method \code{get_data()}}{
Gets filtered or unfiltered dataset.

For \code{filtered = FALSE}, the original data set with
\code{set_data} is returned including all attributes.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_data(dataname, filtered = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{(\code{character(1)}) name of the dataset}

\item{\code{filtered}}{(\code{logical}) whether to return a filtered or unfiltered dataset}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-get_call"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-get_call}{}}}
\subsection{Method \code{get_call()}}{
Gets a \code{call} to filter the dataset according to the filter state.

It returns a \code{call} to filter the dataset only, assuming the
other (filtered) datasets it depends on are available.

Together with \code{self$datanames()} which returns the datasets in the correct
evaluation order, this generates the whole filter code, see the function
\code{FilteredData$get_filter_code}.

For the return type, note that \code{rlang::is_expression} returns \code{TRUE} on the
return type, both for base R expressions and calls (single expression,
capturing a function call).

The filtered dataset has the name given by \code{self$filtered_dataname(dataname)}

This can be used for the \verb{Show R Code} generation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_call(dataname, sid = character(0))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{(\code{character(1)}) name of the dataset}

\item{\code{sid}}{(\code{character(1)}) id of the filter state to exclude from the call}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{call} or \code{list} of calls) to filter dataset calls
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-set_join_keys"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-set_join_keys}{}}}
\subsection{Method \code{set_join_keys()}}{
Set the \code{join_keys}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$set_join_keys(join_keys)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{join_keys}}{(\code{join_keys}) join_key (converted to a nested list)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{self}) invisibly this \code{FilteredData}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-get_join_keys"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-get_join_keys}{}}}
\subsection{Method \code{get_join_keys()}}{
Get join keys between two datasets.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_join_keys()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
(\code{join_keys})
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-get_keys"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-get_keys}{}}}
\subsection{Method \code{get_keys()}}{
Get keys for the dataset.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$get_keys(dataname)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataname}}{(\code{character(1)}) name of the dataset}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{character}) keys of dataset
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-state_list_get"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-state_list_get}{}}}
\subsection{Method \code{state_list_get()}}{
Returns a list of currently active \code{FilterState} objects.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$state_list_get(state_id = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state_id}}{(\code{character(1)})\cr
name of element in a filter state (which is a \code{reactiveVal} containing a list)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} of \code{FilterState} objects
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-state_list_push"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-state_list_push}{}}}
\subsection{Method \code{state_list_push()}}{
Adds a new \code{FilterState} object to this \code{FilterStates}.\cr
Raises error if the length of \code{x} does not match the length of \code{state_id}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$state_list_push(x, state_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{(\code{FilterState})\cr
object to be added to filter state list}

\item{\code{state_id}}{(\code{character(1)})\cr
name of element in a filter state (which is a \code{reactiveVal} containing a list)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-state_list_remove"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-state_list_remove}{}}}
\subsection{Method \code{state_list_remove()}}{
Removes a single filter state with all associated shiny elements:\cr
\itemize{
\item specified \code{FilterState} from \code{private$state_list}
\item UI card created for this filter
\item observers tracking the selection and remove button
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$state_list_remove(state_id, force = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state_id}}{(\code{character})\cr
names of element in a filter state (which is a \code{reactiveVal} containing a list)}

\item{\code{force}}{(\code{logical(1)})\cr
include locked filter states}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-FilteredData-clone"></a>}}
\if{latex}{\out{\hypertarget{method-FilteredData-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FilteredData$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
