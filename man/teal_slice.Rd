% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/teal_slice.R
\name{teal_slice}
\alias{teal_slice}
\alias{is.teal_slice}
\alias{as.teal_slice}
\alias{as.list.teal_slice}
\alias{format.teal_slice}
\alias{print.teal_slice}
\title{Filter metadata}
\usage{
teal_slice(
  dataname,
  varname,
  id,
  expr,
  choices = NULL,
  selected = NULL,
  keep_na = NULL,
  keep_inf = NULL,
  fixed = FALSE,
  locked = FALSE,
  multiple = TRUE,
  title = NULL,
  ...
)

is.teal_slice(x)

as.teal_slice(x)

\method{as.list}{teal_slice}(x, ...)

\method{format}{teal_slice}(x, show_all = FALSE, trim_lines = TRUE, ...)

\method{print}{teal_slice}(x, ...)
}
\arguments{
\item{dataname}{(\code{character(1)}) name of data set}

\item{varname}{(\code{character(1)}) name of variable}

\item{id}{(\code{character(1)}) identifier of the filter. Must be specified when \code{expr} is set.
When \code{varname} is specified then \code{id} is set to a \code{"{dataname} {varname}"} .}

\item{expr}{(\code{character(1)}) string providing a logical expression;
Must be a valid R expression which can be evaluated in the context of the data set;
For a \code{data.frame} \code{var == "x"} is sufficient, but \code{MultiAssayExperiment::subsetByColData}
requires \code{dataname} prefix \code{data$var == "x"}.}

\item{choices}{(optional \code{vector}) specifying allowed choices;
When specified it should be a subset of values in variable denoted by \code{varname};
Type and size depends on variable type.}

\item{selected}{(optional \code{vector}) of selected values from \code{choices};
Type and size depends on variable type.}

\item{keep_na}{(optional \code{logical(1)} or \code{NULL}) flag specifying whether to keep missing values}

\item{keep_inf}{(optional \code{logical(1)} or \code{NULL}) flag specifying whether to keep infinite values}

\item{fixed}{(\code{logical(1)}) flag specifying whether to fix this filter state (forbid setting state)}

\item{locked}{(\code{logical(1)}) flag specifying whether to lock this filter state (forbid disabling and removing)}

\item{multiple}{(optional \code{logical(1)}) flag specifying whether more than one value can be selected;
only applicable to \code{ChoicesFilterState} and \code{LogicalFilterState}}

\item{title}{(optional \code{character(1)}) title of the filter. Ignored when \code{varname} is set.}

\item{...}{in \code{teal_slice} method these are additional arguments which can be handled by extensions
of \code{teal.slice} classes. In other methods these are further arguments passed to or from other methods.}

\item{x}{(\code{teal.slice}) object.}

\item{show_all}{(\code{logical(1)}) in \code{format}, \code{print} - indicating whether to show all fields.}

\item{trim_lines}{(\code{logical(1)}) in \code{format}, \code{print} - indicating whether to trim lines.}
}
\value{
\code{teal.slice} object
}
\description{
Filter metadata
}
\details{
\code{teal_slice} object fully describes filter state and can be used to create,
modify, and delete a filter state. A \code{teal_slice} contains a number of common fields
(all named arguments of \code{teal_slice}), some of which are mandatory, but only
\code{dataname} and  either \code{varname} or \code{expr} must be specified, while the others have default
values.

Setting any of the other values to NULL means that those properties will not be modified
(when setting an existing state) or that they will be determined by data (when creating new a new one).
Entire object is \code{FilterState} class member and can be accessed with \code{FilterState$get_state()}.

\code{teal_slice()} returns two types of \code{teal_slice} objects:
\enumerate{
\item \code{teal_slice_var} - returned when \code{varname} is set. The object keep information about the
variable name, possible choices, and selected values and is used to create an interactive
filter.
\item \code{teal_slice_expr} - returned when \code{expr} is set. The object keeps information about the
expression and is used to create a static filter which evaluates always the same expression.
When \code{expr} is specified \code{varname}, \code{choices}, \code{selected}, \code{multiple}, \code{keep_na}, \code{keep_inf}
are ignored.
}

All \code{teal_slice} fields can be passed as arguments to \code{FilterState} constructors.
A \code{teal_slice} object can be passed to \code{FilterState$set_state}, which will modify the state.
However, once a \code{FilterState} is created, only the \strong{mutable} features can be set with a \code{teal_slice}:
\code{selected}, \code{keep_na} and \code{keep_inf}.

Special consideration is given to two fields: \code{fixed} and \code{locked}.
These are always immutable logical flags that default to \code{FALSE}.
In a \code{FilterState} instantiated with \code{fixed = TRUE} the features
\code{selected}, \code{keep_na}, \code{keep_inf} cannot be changed.
}
\section{Filters in \code{SumarizedExperiment} and \code{MultiAssayExperiment} objects}{


To establish a filter on a column in a \code{data.frame}, \code{dataname} and \code{varname} are sufficient.
For filters referring to \code{colData} of \code{MultiAssayExperiment} object (subjects filter) no extra arguments are needed.
Filter states  created for \code{experiments} require more information as each variable is either located in
the specific \code{ExperimentList} slot. To correctly specify filter for an \code{SummarizedExperiment} one must set:
\itemize{
\item \code{experiment} (\code{character(1)}) name of the experiment in \code{MultiAssayExperiment} object.
\item \code{arg} (\code{"subset"}  or \verb{"select}) to refer to the particular argument in the \code{\link[=subset]{subset()}} function for
\code{SummarizedExperiment}.
}
}

\examples{
x <- teal_slice(
  dataname = "data",
  id = "Female adults",
  expr = "SEX == 'F' & AGE >= 18",
  title = "Female adults"
)
x2 <- teal_slice(
  dataname = "data",
  varname = "var",
  choices = c("F", "M", "U"),
  selected = "F",
  keep_na = TRUE,
  keep_inf = TRUE,
  fixed = FALSE,
  locked = FALSE,
  multiple = TRUE,
  id = "Gender",
  extra_arg = "extra"
)

is.teal_slice(x)
as.list(x)
as.teal_slice(list(dataname = "a", varname = "var"))
format(x, show_all = FALSE, trim_lines = TRUE)
print(x, show_all = FALSE, trim_lines = TRUE)

}
\keyword{internal}
