% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/teal_slice.R
\name{teal_slice}
\alias{teal_slice}
\alias{filter_var}
\alias{filter_expr}
\alias{filter_settings}
\alias{is.teal_slice}
\alias{as.teal_slice}
\alias{c.teal_slice}
\alias{format.teal_slice}
\alias{print.teal_slice}
\alias{is.teal_slices}
\alias{as.teal_slices}
\alias{[.teal_slices}
\alias{c.teal_slices}
\alias{format.teal_slices}
\alias{print.teal_slices}
\alias{slices_field}
\alias{slices_which}
\title{Manage filter state(s).}
\usage{
filter_var(
  dataname,
  varname,
  choices = NULL,
  multiple = NULL,
  selected = NULL,
  keep_na = NULL,
  keep_inf = NULL,
  disabled = FALSE,
  fixed = FALSE,
  locked = FALSE,
  ...
)

filter_expr(dataname, id, title, expr, disabled = FALSE, locked = FALSE, ...)

filter_settings(
  ...,
  exclude_varnames = NULL,
  include_varnames = NULL,
  count_type = NULL
)

is.teal_slice(x)

as.teal_slice(x)

\method{c}{teal_slice}(...)

\method{format}{teal_slice}(x, show_all = FALSE, ...)

\method{print}{teal_slice}(x, ...)

is.teal_slices(x)

as.teal_slices(x)

\method{[}{teal_slices}(x, i)

\method{c}{teal_slices}(...)

\method{format}{teal_slices}(x, show_all = FALSE, ...)

\method{print}{teal_slices}(x, ...)

slices_field(tss, field)

slices_which(tss, expr)
}
\arguments{
\item{dataname}{\code{character(1)} name of data set}

\item{varname}{\code{character(1)} name of variable}

\item{choices}{optional vector specifying allowed choices;
possibly a subset of values in data; type and size depends on variable type}

\item{multiple}{(\code{logical(1)})\cr
flag specifying whether the \code{FilterState} more than one value can be selected;
only applicable to \code{FilterStateChoices} and \code{FilterStateLogical}}

\item{selected}{optional vector specifying selection;
type and size depends on variable type}

\item{keep_na}{\code{logical(1)} or \code{NULL} optional logical flag specifying whether to keep missing values}

\item{keep_inf}{\code{logical(1)} or \code{NULL} optional logical flag specifying whether to keep infinite values}

\item{disabled}{(\code{logical(1)})\cr
flag specifying whether the \code{FilterState} is initiated disabled}

\item{fixed}{\code{logical(1)} logical flag specifying whether to fix this filter state (forbid setting state)}

\item{locked}{\code{logical(1)} logical flag specifying whether to lock this filter state (forbid disabling and removing)}

\item{...}{for \code{filter_var} and \code{filter_expr} any number of additional fields given as \code{name:value} pairs\cr
for \code{filter_settings} any number of \code{teal_slice} objects\cr
for other functions arguments passed to other methods}

\item{id}{(\code{character(1)})\cr
identifier of the filter}

\item{title}{(\code{reactive})\cr
title of the filter (used by \code{filter_expr})}

\item{expr}{(\code{language})\cr
logical expression written in executable way, see \code{Details}
where "executable" means
that a \code{subset} call should be able to evaluate this without failure. For
example \code{MultiAssayExperiment::subsetByColData} requires variable names prefixed
by \code{dataname} (e.g. \code{data$var1 == "x" & data$var2 > 0}). For \code{data.frame} call
can be written without prefixing \code{var1 == "x" & var2 > 0}.}

\item{include_varnames, exclude_varnames}{\verb{named list}s of \code{character} vectors where list names
match names of data sets and vector elements match variable names in respective data sets;
specify which variables are allowed to be filtered; see \code{Details}}

\item{count_type}{\code{character(1)} string specifying how observations are tallied by these filter states.
Possible options:
\itemize{
\item \code{"all"} to have counts of single \code{FilterState} to show number of observation in filtered
and unfiltered dataset.
\item \code{"none"} to have counts of single \code{FilterState} to show unfiltered number only.
}}

\item{show_all}{\code{logical(1)} specifying whether NULL elements should also be printed}

\item{tss}{\code{teal_slices}}

\item{field}{\code{character(1)} name of \code{teal_slice} element}
}
\value{
\code{filter_var} returns object of class \code{teal_slice}, which is a named list.
\code{filter_expr} returns object of class \code{teal_slice_expr}, which inherits from \code{teal_slice}.
\code{filter_settings} returns object of class \code{teal_slices}, which is an unnamed list of \code{teal_slice} objects.
}
\description{
Functions for passing filter state information between objects.
}
\details{
These functions create and manage filter state specifications.
A single filter state can be fully described by a \code{teal_slice} object and such
objects will be used to create, modify, and delete a filter state.

A \code{teal_slice} contains a number of common fields (all named arguments of \code{filter_var}),
some of which are mandatroy, but only \code{dataname} and \code{varname} must be specified,
while the others have default values.
Setting any of the other values to NULL means that those properties will not be modified
(when setting an existing state) or that they will be determined by data (when creating new a new one).
Each of the common fields corresponds to one private field in \code{FilterState}
where it is stored and from where it is retrieved when calling \code{FiterState$get_state}.

A \code{teal_slice} can also contain any number of additional fields, passed to \code{...}
as \code{name:value} pairs. These are collated into a list and stored in the
\code{private$extras} field in \code{FilterState}.

All \code{teal_slice} fields can be passed as arguments to \code{FilterState} constructors.
A \code{teal_slice} can be passed to \code{FilterState$set_state}, which will modify the state.
However, once a \code{FilterState} is created, only the \strong{mutable} features can be set with a \code{teal_slice}:
\code{selected}, \code{keep_na}, \code{keep_inf}, and \code{disabled}.

Special consideration is given to two fields: \code{fixed} and \code{locked}.
These are always immutable logical flags that default to FALSE.
In a \code{FilterState} instantiated with \code{fixed = TRUE} the features \code{selected}, \code{keep_na}, \code{keep_inf}
cannot be changed but the \code{disabled} feature can.
A \code{FilterState} instantiated with \code{locked = TRUE} cannot be disabled or removed.
Any combination of \code{fixed} and \code{locked} is permitted.

\code{filter_var} creates a \code{teal_slice} object, which specifies a filter for a single variable,
passed to and resolved by \code{FilterState} objects.
\code{filter_settings} collates multiple \code{teal_slice} objects into \code{teal_slices},
a complete filter specification. This is used by all classes above \code{FilterState}
as well as \code{filter_panel_api} wrapper functions.
\code{teal_slices} also specifies which variables cannot be filtered
and how observations are tallied, which is resolved by \code{FilterStates}.

\code{include_varnames} and \code{exclude_varnames} in attributes in \code{teal_slices}
determine which variables can have filters assigned.
The former enumerates allowed variables, the latter enumerates forbidden values.
Since these can be mutually exclusive in some cases, they cannot both be set in one \code{teal_slices} object.
}
\section{Filters in \code{SumarizedExperiment} and \code{MultiAssayExperiment} objects}{


To establish a filter on a column in a \code{data.frame}, \code{dataname} and \code{varname} are sufficient.
Filter states created created for \code{SummarizedExperiments} require more information
as each variable is either located in the \code{rowData} or \code{colData} slots.
Thus, \code{teal_slice} objects that refer to such filter states must also contain the field \code{arg}
that specifies "subset" for variables in \code{rowData} and "select" for those in \code{colData}.

Likewise, observations in a \code{MultiAssayExpeeiment} can be filtered based on the content of the \code{colData} slot
or based on the contents of \code{rowData} and \code{colData} of any of its experiments. Hence, another field is necessary.
\code{teal_slice} objects referring to \code{MultiAssayExperiment} objects must contain the field \code{datalabel}
that names either an experiment (as listed in \verb{experimentList(<MAE>)}) or "subjects"
if it refers to the \code{MultiAssaysExperiment} \code{colData}. They must \strong{also} specify \code{arg} as "subset" or "select"
for experiments and as "y" for \code{colData}.
}

\examples{
filter_1 <- filter_var("dataname1", "varname1", letters, "b", FALSE, extra1 = "extraone")
filter_2 <- filter_var("dataname1", "varname2", 1:10, 2, TRUE, FALSE, extra2 = "extratwo")
filter_3 <- filter_var("dataname2", "varname3", 1:10 / 10, 0.2, TRUE, FALSE,
  extra1 = "extraone", extra2 = "extratwo"
)

all_filters <- filter_settings(
  filter_1,
  filter_2,
  filter_3,
  exclude_varnames = list(
    "dataname1" = "varname2"
  )
)

teal.slice:::slices_which(all_filters, 'dataname == "dataname2"')
x <- "dataname2"
teal.slice:::slices_which(all_filters, sprintf('dataname == "\%s"', x))
teal.slice:::slices_field(all_filters, "dataname")

filter_expr(
  dataname = "data",
  id = "FA",
  title = "Female adults",
  expr = "SEX == 'F' & AGE >= 18"
)
}
\keyword{internal}
