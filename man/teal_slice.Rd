% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/teal_slice.R
\name{teal_slice}
\alias{teal_slice}
\alias{filter_var}
\alias{filter_expr}
\alias{filter_settings}
\alias{is.teal_slice}
\alias{as.teal_slice}
\alias{c.teal_slice}
\alias{format.teal_slice}
\alias{print.teal_slice}
\alias{is.teal_slices}
\alias{as.teal_slices}
\alias{[.teal_slices}
\alias{c.teal_slices}
\alias{format.teal_slices}
\alias{print.teal_slices}
\alias{slices_field}
\alias{slices_which}
\title{Manage filter state(s).}
\usage{
filter_var(
  dataname,
  varname,
  choices = NULL,
  selected = NULL,
  keep_na = NULL,
  keep_inf = NULL,
  fixed = FALSE,
  disabled = FALSE,
  ...
)

<<<<<<< HEAD
filter_expr(id, title, dataname, expr, disabled = FALSE)

filter_settings(..., exclude = list(), count_type = c("all", "none"))
=======
filter_settings(
  ...,
  exclude_varnames = NULL,
  include_varnames = NULL,
  count_type = NULL
)
>>>>>>> filter_panel_refactor@main

is.teal_slice(x)

as.teal_slice(x)

\method{c}{teal_slice}(...)

\method{format}{teal_slice}(x, show_all = FALSE, ...)

\method{print}{teal_slice}(x, ...)

is.teal_slices(x)

as.teal_slices(x)

\method{[}{teal_slices}(x, i)

\method{c}{teal_slices}(...)

\method{format}{teal_slices}(x, show_all = FALSE, ...)

\method{print}{teal_slices}(x, ...)

slices_field(tss, field)

slices_which(tss, expr)
}
\arguments{
\item{dataname}{\code{character(1)} name of data set}

\item{varname}{\code{character(1)} name of variable}

\item{choices}{optional vector specifying allowed choices;
possibly a subset of values in data; type and size depends on variable type}

\item{selected}{optional vector specifying selection;
type and size depends on variable type}

\item{keep_na}{\code{logical(1)} or \code{NULL} optional logical flag specifying whether to keep missing values}

\item{keep_inf}{\code{logical(1)} or \code{NULL} optional logical flag specifying whether to keep infinite values}

\item{fixed}{\code{logical(1)} logical flag specifying whether to fix this filter state (i.e. forbid setting state)}

\item{disabled}{\code{logical(1)}logical flag specifying whether to disable this filter state}

\item{...}{for \code{filter_var} any number of additional fields given as \code{name:value} pairs\cr
for \code{filter_settings} any number of \code{teal_slice} objects\cr
for other functions arguments passed to other methods}

<<<<<<< HEAD
\item{expr}{\code{character} string representing and expression that evaluates to a single \code{logical};
will be evaluated in individual \code{teal_slice} objects}

\item{exclude}{\verb{named list} of \code{character} vectors where list names match names of data sets
=======
\item{exclude_varnames}{\verb{named list} of \code{character} vectors where list names match names of data sets
and vector elements match variable names in respective data sets;
specifies which variables are not allowed to be filtered.
Both \code{include_varnames} and \code{exclude_varnames} can't be specified for the same dataset in the same call.}

\item{include_varnames}{\verb{named list} of \code{character} vectors where list names match names of data sets
>>>>>>> filter_panel_refactor@main
and vector elements match variable names in respective data sets;
specifies which variables are not allowed to be filtered.
Both \code{include_varnames} and \code{exclude_varnames} can't be specified for the same dataset in the same call.}

\item{count_type}{\code{character(1)} string specifying how observations are tallied by these filter states.
Possible options:
\itemize{
\item \code{"all"} to have counts of single \code{FilterState} to show number of observation in filtered
and unfiltered dataset.
\item \code{"none"} to have counts of single \code{FilterState} to show unfiltered number only.
}}

\item{show_all}{\code{logical(1)} specifying whether NULL elements should also be printed}

\item{tss}{\code{teal_slices}}

\item{field}{\code{character(1)} name of \code{teal_slice} element}

\item{expr}{\code{character} string representing an expression that evaluates to a single \code{logical};
will be evaluated in individual \code{teal_slice} objects}
}
\value{
\code{filter_var} returns object of class \code{teal_slice}, which is a named list.
\code{filter_settings} returns object of class \code{teal_slices}, which is an unnamed list of \code{teal_slice} objects.
}
\description{
Functions for passing filter state information between objects.
}
\details{
These functions create and manage filter state specifications.
A single filter state can be fully described by a \code{teal_slice} object and such
objects will be used to create, modify, and delete a filter state.

A \code{teal_slice} contains a number of common fields (all named arguments of \code{filter_var})
but only \code{dataname} and \code{varname} are mandatory, while the others have default values.
Setting any of the other values to NULL means that these parameters will not be modified
(when setting an existing state) or that they will be determined by data (when creating new a new one).
Each of the common fields corresponds to one private field in \code{FilterState}
where it is stored and from where it is retrieved when calling \code{FiterState$get_state}.

A \code{teal_slice} can also contain any number of additional fields, passed to \code{...}
as \code{name:value} pairs. These are collated into a list and stored in the
\code{private$extras} field.

All \code{teal_slice} fields can be passed as arguments to \code{FilterState} constructors.
A \code{teal_slice} can be passed to \code{FilterState$set_state}, which will modify the state.
However, once a \code{FilterState} is created, only the \strong{mutable} features can be set with a \code{teal_slice}:
\code{selected}, \code{keep_na}, \code{keep_inf}, and \code{disabled}.

Special consideration is given to the \code{fixed} field. This is always a logical flag that defaults to FALSE.
In a \code{FilterState} instantiated with \code{fixed = TRUE} the features \code{selected}, \code{keep_na}, \code{keep_inf}
cannot be changed but the\code{disabled} can.

\code{filter_var} creates a \code{teal_slice} object, which specifies a filter for a single variable,
passed to and resolved by \code{FilterState} objects.
\code{filter_settings} collates multiple \code{teal_slice} objects into \code{teal_slices},
a complete filter specification. This is used by all classes above \code{FilterState}
as well as \code{filter_panel_api} wrapper functions.
\code{teal_slices} also specifies which variables cannot be filtered
and how observations are tallied, which is resolved by \code{FilterStates}.
}
\section{Filters in \code{SumarizedExperiment} and \code{MultiAssayExperiment} objects}{


To establish a filter on a column in a \code{data.frame}, \code{dataname} and \code{varname} are sufficient.
Filter states created created for \code{SummarizedExperiments} require more information
as each variable is either located in the \code{rowData} or \code{colData} slots.
Thus, \code{teal_slice} objects that refer to such filter states must also contain the field \code{target}
that specifies "subset" for variales in \code{rowData} and "select" for those in \code{colData}.

Likewise, observations in a \code{MultiAssayExpeeiment} can be filtered based on the content of the \code{colData} slot
or based on the contents of \code{rowData} and \code{colData} of any of its experiments. Hence, another field is necessary.
\code{teal_slice} objects refering to \code{MultiAssayExperiment} objects must contain the field \code{datalabel}
that names either an experiment (as listed in \verb{experimentList(<MAE>)}) or "subjects"
if it referes to the MAE's \code{colData}. They must \strong{also} specify \code{target} as "subset" or "select"
for experiments and as "y" for \code{colData}.
}

\examples{
filter_1 <- filter_var("dataname1", "varname1", letters, "b", FALSE, extra1 = "extraone")
filter_2 <- filter_var("dataname1", "varname2", 1:10, 2, TRUE, FALSE, extra2 = "extratwo")
filter_3 <- filter_var("dataname2", "varname3", 1:10 / 10, 0.2, TRUE, FALSE,
                       extra1 = "extraone", extra2 = "extratwo")

all_filters <- filter_settings(
  filter_1,
  filter_2,
  filter_3,
  exclude = list(
    "dataname1" = "varname2"
  )
)

teal.slice:::slices_which(all_filters, 'dataname == "dataname2"')
x <- "dataname2"
teal.slice:::slices_which(all_filters, sprintf('dataname == "\%s"', x))
teal.slice:::slices_field(all_filters, "dataname")

}
\keyword{internal}
