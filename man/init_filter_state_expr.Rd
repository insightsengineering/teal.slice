% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FilterState-utils.R
\name{init_filter_state_expr}
\alias{init_filter_state_expr}
\title{Initialize a \code{FilterStateExpr} object}
\usage{
init_filter_state_expr(slice)
}
\arguments{
<<<<<<< HEAD
\item{slice}{(\code{teal_slice_expr})\cr
object created using \code{\link[=filter_expr]{filter_expr()}}. \code{teal_slice} is stored
in the class and \code{set_state} directly manipulates values within \code{teal_slice}. \code{get_state}
returns \code{teal_slice} object which can be reused in other places. Beware, that \code{teal_slice}
is an immutable object which means that changes in particular object are automatically
reflected in all places which refer to the same \code{teal_slice}.}
=======
\item{id}{(\code{character(1)})\cr
identifier of the filter}

\item{title}{(\code{character(1)})\cr
title of the filter}

\item{dataname}{(\code{character(1)})\cr
name of the dataset where \code{expr} could be executed on.}

\item{expr}{(\code{character(1)})\cr
logical expression written in executable way. By "executable" means
that \code{subset} call should be able to evaluate this without failure. For
example \code{MultiAssayExperiment::subsetByColData} requires variable names prefixed
by dataname (e.g. \code{data$var1 == "x" & data$var2 > 0}). For \code{data.frame} call
can be written without prefixing \code{var1 == "x" & var2 > 0}.}

\item{disabled}{(\code{logical(1)})\cr
flag specifying whether the \code{FilterState} is initiated disabled}

\item{...}{additional arguments to be saved as a list in \code{private$extras} field}

\item{locked}{(\code{logical(1)})\cr
flag specifying whether the \code{FilterState} is initiated locked}
>>>>>>> filter_panel_refactor@main
}
\value{
\code{FilterStateExpr} object
}
\description{
Initialize a \code{FilterStateExpr} object
}
\keyword{internal}
