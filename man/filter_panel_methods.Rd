% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-documentation.R
\name{filter_panel_methods}
\alias{filter_panel_methods}
\title{Methods for custom data class}
\arguments{
\item{data}{(\code{object}) Object of any class}

\item{data_filtered}{(\code{object}) Object of any class but must be the same class as \code{data}}

\item{dataname}{(\code{character}) Name of the dataset}

\item{filtered_data}{(\code{FilteredData}) Object of class \code{FilteredData}.}

\item{states_list}{(\code{list}) List of \code{FilterState} objects}
}
\description{
Methods for custom data class
}
\section{Supported data types}{
\code{teal.slice} provide methods for:
\itemize{
\item \code{data.frame}
\item \code{DFrame}
\item \code{matrix}
\item \code{Matrix}
\item \code{SummarizedExperiment}
\item \code{MultiAssayExperiment}
}

Datasets which don't inherit from these classes will trigger default methods which in most of the
cases do nothing. Methods for unsupported data types are made in a way that they don't break the app.
If you want to extend filter panel for your custom data type, you can register S3 methods for
any of these methods. For example, if you want to extend filter panel for \code{custom_class}, you can
register a new S3 methods \verb{<method>.custom_class} where \verb{<method>} is one of the exported \code{teal.slice} methods.

Same applies to supported data types. If you want to override default methods for any of the supported
data types, say data.frame, you can register a new S3 methods \verb{<method>.data.frame}.
}

\seealso{
\link{module_active}, \link{module_overview}, \link{get_filter_overview},
\link{module_add}, \link{get_filter_call}, \link{get_slice_variable}
}
\keyword{internal}
