% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_state_api_NEW.R
\name{filter_var}
\alias{filter_var}
\alias{filter_settings}
\title{single variable filter}
\usage{
filter_var(
  dataname,
  varname,
  choices = NULL,
  selected = NULL,
  varlabel = NULL,
  keep_na = NULL,
  keep_inf = NULL,
  fixed = FALSE
)

filter_settings(
  ...,
  filterable = list(),
  count_type = c("none", "all", "hierarchical")
)
}
\arguments{
\item{dataname}{\code{character(1)} name of data set}

\item{varname}{\code{character(1)} name of variable}

\item{choices}{vector specifying allowed choices;
possibly a subset of values in data;
type and size depends on variable type}

\item{selected}{vector specifying selection;
type and size depends on variable type}

\item{varlabel}{\code{character(0-1)} optional variable label}

\item{keep_na}{\code{logical(0-1)} optional logical flag specifying whether to keep missing values}

\item{keep_inf}{\code{logical(0-1)} optional logical flag specifying whether to keep infinite values}

\item{fixed}{\code{logical(1)} logical flag specifying whether to fix this filter state (i.e. forbid setting state)}

\item{...}{any number of \code{teal_slice} objects}
}
\value{
Object of class \code{teal_slice}, which is a named list.

Object of class \code{teal_slices}, which is an unnamed list of \code{teal_slice} objects.
}
\description{
Specifies a filter state.

Collate single variable filter states into a complete filter specification.
}
\examples{
filter_one <- filter_var("dataname1", "varname1", letters, "b", "characters", FALSE)
filter_two <- filter_var("dataname1", "varname2", 1:10, 2, "integers", TRUE, FALSE)
filter_three <- filter_var("dataname2", "varname3", 1:10/10, 0.2, "doubles", TRUE, FALSE)

all_filters <- filter_settings(
  filter_one,
  filter_two,
  filter_three,
  filterable = list(
    "dataname1" = c("varname1", "varname2"),
    "dataname2" = "varname3"
  )
)

}
