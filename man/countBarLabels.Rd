% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count_labels.R
\name{countBars}
\alias{countBars}
\alias{updateCountBars}
\title{Progress bars with labels}
\usage{
countBars(inputId, choices, countsmin, countsmax, countsnow = NULL)

updateCountBars(
  session = getDefaultReactiveDomain(),
  inputId,
  choices,
  countsmin,
  countsmax,
  countsnow = NULL
)
}
\arguments{
\item{inputId}{(\code{character(1)}) \code{shiny} id}

\item{choices}{(\code{vector}) determines label text.}

\item{countsmin}{(\code{numeric}) determining minimal count of each element.
Length should be the same as \code{choices}}

\item{countsmax}{(\code{numeric}) determining maximal count of each element.
Length should be the same as \code{choices}.}

\item{countsnow}{(\code{numeric}) actual counts of each element.
Length should be the same as \code{choices}.}

\item{session}{(\code{session}) object passed to function given to \code{shinyServer}.}

\item{counttotal}{(\code{numeric(1)}) Determines the size of the whole progress bar.
For example, in case there are three choices with some counts, one might like
to display each progress bar with the relative size to the \code{totalcount}.}
}
\value{
list of \code{shiny.tag}
}
\description{
\code{shiny} element showing progressbar counts. Each element can has
unique \code{id} attribute so each can be used independently.
Progress bar size is dependent on the ratio \code{choicesnow[i] / countsmax[i]}.
Label is \code{choices[i] (countsnow[i]/countsmax)}
}
\examples{

choices <- sample(as.factor(c("a", "b", "c")), size = 20, replace = TRUE)
counts <- table(choices)
labels <- countBars(
  inputId = "counts",
  choices = c("a", "b", "c"),
  countsmax = c(20, 20, 20),
  countsnow = unname(counts)
)


shinyApp(
  ui = fluidPage(
    div(
      class = "choices_state",
      teal.slice:::include_js_files("count-bar-labels.js"),
      checkboxGroupInput(
        inputId = "choices",
        choices = levels(choices),
        selected = levels(choices),
        label = NULL
      ),
      labels
    )
  ),
  server = function(input, output, session) {
    observeEvent(input$choices, {
      new_counts <- counts
      new_counts[!names(new_counts) \%in\% input$choices] <- 0

      updateCountBars(
        inputId = "counts",
        choices = levels(choices),
        countsmax = c(20, 20, 20),
        countsnow = unname(new_counts)
      )
    })
  }
)
}
\keyword{internal}
